\documentclass{article}
 
\usepackage{amscd}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage[section]{placeins} % float barriers
\usepackage{natbib}
\usepackage{xcolor} 
\usepackage{bussproofs} 
\usepackage{diagrams}
\usepackage{tikz}
 
\usetikzlibrary{cd}
 
\newtheorem{lemma}{Lemma}

%example: \limit{j \in J}{F_j}
\newcommand{\limit}[2]{\underset{\overset{\longleftarrow}{#1}}{\text{lim}}~#2}
\newcommand{\lims}[1]{\underset{\longleftarrow}{\text{lim}}~#1}
\newcommand{\mbf}{\mathbf}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\defeq}{\overset{\mathit{def}}{=}}


\newcommand{\vrt}[2]{
\pile{
#1 \\
\downarrow \\
#2
}
}

\newcommand{\ddisp}[3]{
\left(
\scriptsize
\begin{tikzcd}
#1 \ar[d, "\footnotesize{#2}"] \\
#3
\end{tikzcd}
\normalsize
\right)
}

\newcommand{\disp}[3]{
\left(
\tiny
\begin{array}{c}
#1 \\
\downarrow\\
#3
\end{array}
\begin{array}{l}
~ \\
#2 \\
~
\end{array}
\normalsize
\right)
}

\newcommand{\dispp}[3]{
\tiny
\begin{tikzcd}
#1 \ar[d, "#2"] \\
#3
\end{tikzcd}
\normalsize
}

\title{Schema Type Calculus}

\begin{document}

\maketitle

\section*{Syntax}

\begin{tabular}{llll}
$c$ & $\in$ & $\mathit{Chars}$ & (the finite set of all characters) \\
$\phi$ & $\in$ & $\mathcal P(\mathit{Chars})$ & (a subset of the set of characters) \\
$s,t \in S$ & $=$ & $\mathit{Chars}^{\star}$ & (strings) \\~\\
$d$ (discriminator) & $::=$  & $\mathit{Prefix}~s$ & (values begin with $s$) \\
    & $\mid$ & $\mathit{Literal}~s$ & (values are equal to $s$) \\
 & & \\
$m$ (multiplicity) & $::=$ & $1,\mathit{set},\mathit{opt}$\\~\\
$\tau,\sigma$ (type) & $::=$ & $\mathit{tuple} \{ s_i : \tau_i : c_i^{~i \in 1..n} \}$ & (pieced string) \\
       & $\mid$ & $s$ & (string literal type) \\
       & $\mid$ & $\biguplus \tau_i^{~i \in 1..n}$ & (union of disjoint types) \\ 
       & $\mid$ & $\tau.\{[\sigma_i] :^{m_i} \tau_i ^{~i \in 1..n}\}$ & (record type - $\mathit{root}.\{ fields \}$) \\ 
       & $\mid$ & $\forall (x :: \kappa). \tau$ & (type abstraction) \\~\\
$\kappa$ (kind) & $::=$ & $\mathit{KString}(d,\phi)$ & (Kind of string types, chars in vals drawn from $\phi$) \\
                         & $\mid$ & $\mathit{KStringLit}$ & (Kind of string literal types) \\
                         & $\mid$ & $\mathit{KTree}(d)$ & (Kind of tree types w/ root discriminator $d$) \\
                         & $\mid$ & $\kappa \Rightarrow \kappa$ & (Kind of type abstractions) \\
\end{tabular}\\~\\~\\
\begin{tabular}{llll}

\end{tabular}

\section*{Discriminator subsumption}

\begin{mathpar}
\inferrule
  {s' \sqsubseteq s}
  {\mathit{Prefix}~s \leq \mathit{Prefix}~s'}
\and
\inferrule
  {s' \sqsubseteq s}
  {\mathit{Literal}~s \leq \mathit{Literal}~s'}
\and
\inferrule
  {s' \sqsubseteq s}
  {\mathit{Literal}~s \leq \mathit{Prefix}~s'}
\end{mathpar}

Above, $s' \sqsubseteq s$ means ``$s'$ is a prefix of $s$''.

\section*{Subkinding}

\begin{mathpar}
\inferrule
  {d \leq d'}
  {\mathit{KString}(d,\phi) <:: \mathit{KTree}(d)}
\and
\inferrule
  {~}
  {\mathit{KString}(\mathit{Literal}~s,\phi) <:: \mathit{KStringLit}}
\and
\inferrule
  {d \leq d' \\ \phi \subseteq \phi'}
  {\mathit{KString}(d,\phi) <:: \mathit{KString}(d',\phi')}
\and
\inferrule
  {d \leq d'}
  {\mathit{KTree}(d) <:: \mathit{KTree}(d')}
\end{mathpar}

\section*{Kinding}

\begin{mathpar}
\inferrule
  {\Gamma \vdash \tau_i :: \kappa_i^{~i \in 1..n} \\ 
   \kappa_i <:: \mathit{KString}(d_i,\phi_i)^{~i \in 1..n} \\
   c_i \not \in \phi_i^{~i \in 1..n} }
  {\Gamma \vdash \mathit{tuple} \{ s_i : \tau_i : c_i^{~i \in 1..n}\} :: \mathit{KString}(d_1, (\bigcup_{i \in 1..n} \phi_i) \cup \{ c_1, \ldots, c_n \})}
\and
\inferrule
  {~}
  {\Gamma \vdash s : \mathit{KStringLit}(s)}
\and
\inferrule
  {\Gamma \vdash \tau_i :: \mathit{KTree}(d_i)^{~i \in 1..n} \\ \mathit{disjoint} \{ d_i^{~i \in 1..n} \} }
  {\Gamma \vdash \biguplus_{i \in 1..n} \tau_i :: \mathit{KTree}(\mathit{merge}~\{ d_i^{~i \in 1..n} \})}
\end{mathpar}

We define $\ast \doteq \mathit{KTree}(\mathit{Prefix}~\epsilon)$, where $\epsilon$ is the empty string, so that all proper types have kind $\ast$.

\end{document}
  
