\documentclass[sigplan,10pt,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=true}
\bibliographystyle{ACM-Reference-Format}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{tikz}
\usepackage{quiver}

\usetikzlibrary{cd}

\lstset{
  basicstyle=\small\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  numbers=left
}

\newcommand{\blu}[1]{\textbf{\color{blue}{#1}}}
\newcommand{\blum}[1]{\mathbf{\color{blue}{#1}}}
\newcommand{\defeq}{\overset{\mathit{def}}{=}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\fm}[2]{
\left(
\tiny
#1
\normalsize
\right)_{#2}
}

\title{Indexed Kind Checking for Hierarchical Database Schemas}
\author{Kevin Clancy}

 
\begin{document}

%\category{D.3.3}{Test 1}
%\terms{Languages}
\keywords{Indexed types, Database schemas, Dependent types}
\ccsdesc[100]{NetworksËœNetwork reliability}


\begin{abstract}

Types are an appropriate tool for describing the structure of hierarchical databases. But two common database structure idioms, \emph{foreign keys} and \emph{secondary indices} cannot be expressed using standard type systems. We present a lanaguage in which a database schema is described using a type layered over a dependently sorted index language. The index language consists of keys and relations on keys. Multiple occurrences of the same index-level relation inside of a schema establish a correlation between two distinct portions of a database instance; both secondary indices and foreign keys can be specified in this manner.

%We present a lanaguage in which a database schema is described using a type layered over a dependently sorted index language of keys and relations on keys. A dictionary type constructor binds a sequence of $n$ index variables corresponding to a sequence of $n$ nested keys. It also includes a proposition, typically an application of an $n$-ary predicate on keys, which determines the exact set of key sequences that a database instance must contain. We a reconfiguration by including the same predicate in multiple dictionary types.


\end{abstract}

\maketitle

\section{Introduction}

Programmers increasingly choose document database systems, such as DynamoDB, due to their high performance and intuitive hierarchical structure. Schemas for such databases are often intentionally omitted under the premise that they inhibit rapid iteration. However, we disagree with this premise. We believe that the arguments in favor of database schemas are analogous to those in favor of static types in programming langauges. 

The type syntax of a standard programming lanaguage such as Typescript is, for the most part, an appropriate tool to describe the structure of modern hierarchical databases. However, two common features of hierarchical databases lie beyond the reach of standard type systems. First, a database may store \emph{foreign keys}: values used to refer to entities stored elsewhere in the database. Second, a database may replicate a dataset in multiple configurations, or \emph{secondary indices}, to accomodate multiple access patterns in an efficient, spatially local manner. 

The prevalence of foreign keys in hierarchical databases constrasts sharply against the in-memory data structures one typically finds in general purpose lanaguages. A pointer in a language such as C++ is not a foreign key, because statically our concern is the type of referenced data rather than its location. In contrast, consider an e-commerce database which records purchases performed by customers. Each purchase refers to the credit card used for payment; however, this card is not drawn from a global pool of all cards, but instead the pool of cards owned by the customer which made the purchase. 

Secondary indices are also common and useful database structure beyond the reach of traditional type systems. Consider this example demonstrating the utility of secondary indices. An e-commerce company wishes to issue a recall on a product. To do so, it must obtain a list of all customers that have purchased an item known to be defective; to compute this list efficiently, the set of all customers which purchased each item must be stored in nearby addresses. At another time, a customer may wish to obtain a list of all items he has purchased from the site; to perform this operation efficiently, we must store the set of all of a customer's purchased items in nearby addresses. These two requirements are at odds if our database merely stores a single collection of all purchases processed. However, if we redundantly store customer-to-item and item-to-customers map, we can satisfy both requirements at once. Such redundant data structures are called secondary indices.

In practice, foreign keys often refer to deleted entities. Such a foreign key is a time-bomb which will raise an exception the next time the data is accessed. Secondary indices can become out-of-sync due to programmer errors. A formal schema language including notions of foreign keys and indices could be compiled to validation routines to detect these errors. 

\begin{itemize}   
\item We develop a schema language for hierarchical databases with the ability to express foreign keys and secondary indices. 
\item blah blah blah denotational semantics (and operational)
\end{itemize}

Since we are working with two distinct concepts which are both typically referred to as \emph{indices} -- indices in the sense of database indices and indices in the sense of indexed type checking -- we refer to database secondary indices as \emph{reconfigurations} in the sequel.

%Likewise, we don't have 
%Chronicles indexing on pg 9040.


%\pagebreak


\section{Example}


%The schema begins with some predicate declarations. On the first line, 
%``\verb!(ItemId : str -> prop) =>!'' binds a predicate scoped over the rest of the schema fragment. 
%This forms an index-to-type abstraction mapping each unary predicate on strings to a schema.  

%NewMiscStudy pg 9047 describes chronicles indices.

\subsection{Foreign Keys}

\begin{figure}

\begin{lstlisting}[escapeinside=`']
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{ItemId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CustId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{PurchaseId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CardType : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CardId : (x:str) -> prf (CustId x) -> str -> prop}').

type Card = {
  billingAddr : str
  cardType    : { `\blu{x : str}' | `\blu{CardType x}' }
}

type Purchase = `$\lambda$(\blu{cust : str}).$\lambda$(\blu{prf (CustId cust)}).' {
  itemId : { `\blu{x : str}' | `\blu{ItemId x}' }, 
  cardId : { `\blu{x : str}' | `\blu{CardId cust x}' }
}

type Customer = `$\lambda$(\blu{cust : str}).$\lambda$(\blu{prf (CustId cust)}).' { 
  purchases : { 
    [`\blu{p : str}'] : `\blu{PurchaseId p}' > Purchase `\blu{cust}' 
  },
  cards     : { 
    [`\blu{card : str}'] : `\blu{CardId cust card}' > Card 
  }
}

{
  cardTypes : { [`\blu{x : str}'] : `\blu{CardType x}' > "*" }
  customers : { [`\blu{x : str}'] : `\blu{CustId x}' > Customer `\blu{x}'}
}
\end{lstlisting}

\caption{Schema for e-commerce database with foreign keys}
\label{fig:ecommerce}
\end{figure}

The purpose of a schema is to identify a set of database instances, so before examining our first schema we briefly define some formalisms for describing database instances. We consider \emph{database instances} (also called \emph{instances}) as partial mappings from lists of strings to strings. Given a database instance $f$, and a list of strings $\sigma$, we obtain $f |_\sigma$, \emph{the restriction of $f$ to $\sigma$}, defined for lists $\sigma'$ as $f |_\sigma(\sigma') \defeq f(\sigma + \! \! +~\sigma')$, where $\sigma + \! \! +~ \sigma'$ is the concatenation of $\sigma$ and $\sigma'$. By an abuse of language, we say ``$f$ maps $\sigma$ to $f |_{\sigma}$''. We write $[s_1, \ldots, s_n]$ for the list containing the $n$ strings $s_1,\ldots,s_n$. 

Figure \ref{fig:ecommerce} shows a schema fragment for an e-commerce database. It begins by declaring five predicates: first four unary predicates for item ids, customer ids, purchase ids, and card types. Finally, it declares a ternary predicate for card ids. The predicate variables and their classifiers have been bolded and colored blue to indicate that they are part of the \emph{index language}. This simple language defines conceptual entities such as predicates and relations, divorced from the physical details of where these entities are stored. The index langauge is layered beneath our schema language, i.e. schemas may depend on indices but not vice versa. 

Lines 7-10, use the record type constructor to define a subschema representing credit cards. It denotes the set of instances which map the list [``addr''] to any string and the list [``cardType''] to any string satisfying the \lstinline[mathescape]{$\blu{CardType}$} predicate. 

%The field \emph{cardId} is an instance of a foreign key. In this schema language, foreign keys don't refer directly to locations in the database; instead, they refer to index-level unary predicates. By separating conceptual sets (index-level predicates) from their physical  

Lines 12-15 define an index-to-type operator called \emph{Purchase}, which maps a string \lstinline[mathescape]{$\blu{cust}$} and a proof that \lstinline[mathescape]{$\blu{cust}$} satisfies the \lstinline[mathescape]{$\blu{CustId}$} predicate to a type denoting representing purchases made by customer \lstinline[mathescape]{$\blu{cust}$}. In the application \lstinline[mathescape]{$\blu{CardId cust card}$}, the second argument to  \lstinline[mathescape]{CardId} is missing. This is because it is a proof; since any two proofs of the same proposition are interchangeable, we apply proofs implicitly to reduce visual clutter. 

On lines 17-24 define a index-to-type operator \lstinline{Customer} mapping a string \lstinline[mathescape]{$\blu{cust}$} and a proof that \lstinline[mathescape]{$\blu{CustId cust}$} holds to a type representing customers with id \lstinline[mathescape]{$\blu{cust}$}. It denotes the set of instances which
\begin{itemize}
\item Map all lists [``purchases'', \lstinline[mathescape]{$\blu{p}$}] such that \lstinline[mathescape]{$\blu{purchaseId p}$} holds to instances of type \lstinline[mathescape]{Purchase $\blu{cust}$}. 
\item Map all lists [``cards'', \lstinline[mathescape]{$\blu{card}$}] such that \lstinline[mathescape]{$\blu{CardId cust card}$} holds to instances of type \lstinline{Card}.
\end{itemize}

Finally, lines 26-29 define the schema using a record type. It denotes the set of instances which: 
\begin{itemize}
\item Map [``cardTypes''] to a subinstance that stores the set of all card types by mapping each \lstinline[mathescape]{Purchase $\blu{x}$} satisfying the \lstinline[mathescape]{$\blu{CardType}$} predicate to the string \lstinline[mathescape]{"*"}
\item Map [``customers''] to a dictionary that maps every \lstinline[mathescape]{$\blu{x}$} satisfying the \lstinline[mathescape]{$\blu{CustId}$} predicate to a subschema of type \lstinline[mathescape]{Customer $\blu{x}$}. 
\end{itemize}

%The code \lstinline[mathescape]{$\lambda (\blu{ItemId : str -> prop})/$} on the first line is an abstraction mapping indices of sort \lstinline[mathescape]{$\blu{str -> prop}$} to the type whose syntax occupies the remaining lines of the figure. A type denotes a set of database instances.

\subsection*{Reconfigurations}


\begin{figure} 

\begin{small}
\begin{lstlisting}[escapeinside=`']
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{ItemId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CustId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{Purchased : \\ \hspace{1cm} (x : str) -> prf (CustId x) -> \\ \hspace{1cm} (y : str) -> prf (ItemId y) -> prop}').

{ 
  custToItem : { 
    [`\blu{c,i : str}'] : `\blu{CustId c}, 
                           \blu{ItemId i}, 
                           \blu{Purchased c i}' > "*" 
  }
  itemToCust : { 
    [`\blu{i,c : str}'] : `\blu{CustId c}, 
                           \blu{ItemId i}, 
                           \blu{Purchased c i}' > "*"
  }
}
\end{lstlisting}

\end{small}
\caption{Reconfigurations (secondary indices) in an e-commerce database}
\label{fig:ecommerce-indices}
\Description[Secondary indices]{Secondary indices in an e-commerce database}
\end{figure}

Figure \ref{fig:ecommerce-indices} shows a schema for a simple database with reconfigurations. An instance satisfies the schema if 
\begin{itemize}
\item For each customer/item pair \lstinline[mathescape]{$\blu{c}$}, \lstinline[mathescape]{$\blu{i}$} satisfying \lstinline[mathescape]{$\blu{Purchased c i}$}, it maps \lstinline[mathescape]{["custToItem", $\blu{c}$, $\blu{i}$]} to the string \lstinline[mathescape]{"*"} and \lstinline[mathescape]{["itemToCust", $\blu{i}$, $\blu{c}$]} to \lstinline[mathescape]{"*"}.
\item It is not defined anywhere else.
\end{itemize}

Such an instance allows us to efficiently query both the set of all items purchased by a customer (via \lstinline[mathescape]{custToItem} and the set of all customers which purchased an item (via \lstinline[mathescape]{itemToCust}. Importantly, the two fields both refer to the same set of purchase entities via the index-level relation \lstinline[mathescape]{$\blu{Purchased}$}.

\section{Syntax}

\iffalse

\begin{tabular}{llll}
$\mathit{Chars}$ & $\doteq$ & the set of all characters \\
$\mathit{TypeVars}$ & $\doteq$ & the set of all type variables \\
$\mathit{IndexVars}$ & $\doteq$ & the set of all index variables \\
$x,y,z$ & $\in$ & $\mathit{TypeVars}$ & ~ \\
$\blu{a}, \blu{b}, \blu{P}$ & $\in$ & $\mathit{IndexVars}$ & ~ \\
$\blu{c}$ & $\in$ & $\mathit{Chars}$ & (characters) \\
$\blu{s},\blu{t}$ & $\in$ & $\mathit{Strings}$ & (where $\mathit{Strings} = \mathit{Chars}^{\star}$) \\~\\
 & & \\
$\blu{j},\blu{k}$ (index) & ::=  & $\blu{s}$ & (string literal) \\
                          & $\mid$ & $\blu{App_{[a : q],p}(j,k)}$ & (index application) \\
                          & $\mid$ & $\blu{a}$ & (index variable) \\~\\
$\blu{C}$ (string classifiers) & ::= & $\blu{s}$ & (string singleton) \\
                         & $\mid$ & $\blu{str}$ & (all strings) \\~\\
$\blu{q},\blu{r}$ (sort) & ::= & $\blu{C}$ & (sort of strings satisfying $C$) \\
                         & $\mid$ & $\blu{\textbf{prop}}$ & (proposition sort) \\
                         & $\mid$ & $\blu{\textbf{prf}~\phi}$ & (proof sort) \\
                         & $\mid$ & $\blu{(a : q) \Rightarrow r}$ & (dependent function sort) \\~\\
$\kappa,\rho$ (kind) & $::=$ & $\ast$ & (kind of proper types) \\
                     & $\mid$ & $\kappa \to \rho$ & (type-to-type operator)\\
                     & $\mid$ & $\forall \blu{q}.~\kappa$ & (index-to-type operator) \\~\\
$\tau,\sigma$ (type) & $::=$ & $\{[\blu{a : C}] : \tau \}$ & (dictionary type) \\ 
       & $\mid$ & $\{ \blu{s}_i : \tau_i^{~i \in 1..n} \}$ & (record type) \\
       & $\mid$ & $\langle \blu{C} \rangle$ & (string type) \\
       & $\mid$ & $\lambda \blu{a : q} . \tau$ & (index-to-type abstraction) \\
       & $\mid$ & $\lambda x : \kappa. \tau$ & (type-to-type abstraction) \\
       & $\mid$ & $\bigvee \tau$ & (colimit) \\
       & $\mid$ & $\tau~\sigma$ & (type application) \\
       & $\mid$ & $\tau~[~\blu{j}~]$ & (index-to-type application)
\end{tabular}

\fi 

\begin{figure}
\begin{tabular}{llll}
$\mathit{TypeVars}$ & $\defeq$ & the set of all type variables \\
$\mathit{IndexVars}$ & $\defeq$ & the set of all index variables \\
$x,y,z$ & $\in$ & $\mathit{TypeVars}$ & ~ \\
$\blu{a}, \blu{b}, \blu{P}$ & $\in$ & $\mathit{IndexVars}$ & ~ \\
$\blu{s},\blu{t}$ & $\in$ & $\mathit{Strings}$ & ~ \\
\end{tabular}\\~\\~\\
\begin{tabular}{llll}
$\blu{j},\blu{k}$ (indices) & ::=  & $\blum{s}$ & (string literal) \\
                          & $\mid$ & $\blum{App}_{\blum{[a : q],p}}\blum{(j,k)}$ & (index application) \\
                          & $\mid$ & $\blu{a}$ & (index variable) \\
                          & $\mid$ & $\blu{true}$ & (true proposition) \\
~ & ~ & ~ & ~ \\
$\blu{q},\blu{r}$ (sort) & ::= & $\blum{str}$ & (string sort) \\
                         & $\mid$ & $\blum{prop}$ & (proposition sort) \\
                         & $\mid$ & $\blum{prf~j}$ & (proof sort) \\
                         & $\mid$ & $\blum{(a : q) \to r}$ & (function sort) \\
~ & ~ & ~ & ~ \\
$\kappa,\rho$ (kind) & $::=$ & $\ast$ & (proper type kind) \\
                     & $\mid$ & $\kappa \to \rho$ & (type-to-type op)\\
                     & $\mid$ & $\forall \blu{q}.~\kappa$ & (index-to-type op) \\
~ & ~ & ~ & ~ \\
$\tau,\sigma$ (type) & $::=$ & $\{[\blu{a : str}] : \tau \}$ & (dictionary type) \\ 
       & $\mid$ & $\{ \blu{s}_i : \tau_i^{~i \in 1..n} \}$ & (record type) \\
       & $\mid$ & $\{ \blu{a : str} \mid \blu{i} \}$ & (string refinement type) \\
       & $\mid$ & $\lambda \blu{a : q} . \tau$ & (index-to-type abstr.) \\
       & $\mid$ & $\lambda x : \kappa. \tau$ & (type-to-type abstr.) \\
       & $\mid$ & $\bigvee \tau$ & (union) \\
       & $\mid$ & $\tau~\sigma$ & (type app.) \\
       & $\mid$ & $\tau~[~\blu{j}~]$ & (index-to-type app.) 
\end{tabular}\\~\\~\\
\begin{tabular}{llll}
$\blum{\Omega}, \blum{\Psi}$ (pre-index-context) & $::=$  & $\blum{\Omega,a : q}$ & (extension) \\
                                     & $\mid$ & $\blum{\diamond}$ & (empty) \\~\\
$\Gamma$ (kind context) & $::=$ & $\Gamma,x : \kappa$ & (extension) \\
                        & $\mid$ & $\diamond$ & (empty) 
\end{tabular}
\caption{Syntax}
\label{fig:syntax}
\Description[Syntax]{Syntax}
\end{figure}

There is some syntax

\section{Static classification}

\subsection{Sorting}

\begin{figure}
\begin{mathpar}
\inferrule
  {~}
  {\blum{\Omega \vdash s : str}}
\and
\inferrule
  {~}
  {\blum{\Omega,a : q, \Omega' \vdash a : q}}
\and
\inferrule
  {\blum{\Omega \vdash j : (a : q) \to r} \\ \blum{\Omega \vdash k : q}}
  {\blum{\Omega \vdash App_{[a : q],r}(j,k) : r[k/a]}}
\and
\inferrule
  {~}
  {\blum{\Omega \vdash true : prop}}
\and
\inferrule
  {~}
  {\blum{\Omega \vdash str}}
\and
\inferrule
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a:q \vdash r}}
  {\blum{\Omega \vdash (a : q) \Rightarrow r}}
\and
\inferrule
  {\blum{\Omega \vdash j : prop}}
  {\blum{\Omega \vdash prf~j}}
\end{mathpar}
\caption{Sorting and sort formation}
\label{fig:sorting}
\Description[Sorting and sort formation]{Sorting and sort formation rules}
\end{figure}

Here are some sorting and sort formation rules.

\subsection{Kinding}

Here are some kinding and kind formation rules.

\begin{figure}
\begin{mathpar}
\inferrule
  {\blum{\Omega,a : str} \mid \Gamma \vdash \tau : \ast}
  {\blum{\Omega} \mid \Gamma \vdash \{ [\blum{a : str}] : \tau \} : \ast}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau_i : \ast^{~i \in 1..n}}
  {\blum{\Omega} \mid \Gamma \vdash \{ \blum{s}_i : \tau_i^{~i \in 1..n} \} : \ast}
\and
\inferrule
  {\blum{\Omega,a:str \vdash i : prop}}
  {\blum{\Omega} \mid \Gamma \vdash \{ \blum{a : str} \mid \blum{i} \} : \ast}
\and
\inferrule
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a : q} \mid \Gamma \vdash \tau : \kappa}
  {\blum{\Omega} \mid \Gamma \vdash \lambda \blum{a : q} . \tau : \forall \blum{q} . \kappa}
\and
\inferrule
  {\blum{\Omega} \vdash \kappa \\ \blum{\Omega} \mid \Gamma,x:\kappa \vdash \tau : \rho}
  {\blum{\Omega} \mid \Gamma \vdash \lambda x : \kappa. \tau : \kappa \to \rho}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \forall \blum{q}. \ast}
  {\blum{\Omega} \mid \Gamma \vdash \bigvee \tau : \ast}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \forall \blum{q}. \rho \\ \blum{\Omega \vdash j : q}}
  {\blum{\Omega} \mid \Gamma \vdash \tau~[~\blum{j}~]: \rho}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \kappa \to \rho \\ \blum{\Omega} \mid \Gamma \vdash \sigma : \kappa}
  {\blum{\Omega} \mid \Gamma \vdash \tau~\sigma : \rho}
\and
\inferrule
  {~}
  {\blum{\Omega} \vdash \ast}
\and
\inferrule
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a:q} \vdash \kappa}
  {\blum{\Omega} \vdash \forall \blu{q}. \kappa}
\and
\inferrule
  {\blum{\Omega} \vdash \kappa \\ \blum{\Omega} \vdash \rho}
  {\blum{\Omega} \vdash \kappa \to \rho}
\end{mathpar}
\caption{Kinding and kind formation}
\label{fig:kinding}
\Description[Kinding and kind formation]{Kinding and kind formation rules}
\end{figure}

\section{Denotational Semantics}

\subsection{Index Language}

We interpret our index langauage using Dybjer's \emph{Categories-with-Families} (CwF) framework for semantically modeling dependently typed languages \cite{}. We first review the definition of CwF and then provide an interpretation of the index language with respect to a CwF. There is nothing novel about our index language, so both sections are standard. However, we rename some of the standard terminology to fit into the present setting, e.g., instead of types we have sorts.

\subsection{Categories with families}

A category-with-families consists of 
\begin{itemize}
\item A category $\mathbb C$ with a terminal object, called the \emph{category of contexts}. Objects of $\mathbb C$ are called semantic contexts and written with the symbols $\Omega$, $\Psi$, $\Upsilon$.
\item For each semantic context $\Omega$ a collection $\mathit{St}(\Omega)$ called the \emph{semantic sorts} of $\Omega$. Semantic sorts are written with the symbols $X$,$Y$, and $Z$.
\item For each semantic context $\Omega$ and $X \in \mathit{St}(\Omega)$ a collection $\mathit{In}(\Omega,X)$ called the \emph{semantic indices} of sort $X$.
\item For each morphism $f : \Omega \to \Psi$ a mapping $- \{ f \} : \mathit{St}(\Psi) \to \mathit{St}(\Omega)$. These mappings preserve composition, in the sense that we have $- \{ \mathit{id}_{\Omega} \} = \mathit{id}_{\mathit{St}(\Omega)}$, and for $g : \Psi \to \Upsilon$ we have $- \{ g \circ f \} = - \{ g \} \{ f \}$.
\item For each morphism $f : \Omega \to \Psi$ and sort $X \in \mathit{St}(\Psi)$ a mapping $- \{ f \} : \mathit{In}(\Psi,X) \to \mathit{In}(\Omega,X \{ f \})$. These mappings preserve composition in the same sense as above.
\end{itemize}


\subsection{Interpretation}

\begin{figure}
\begin{small}
\begin{tabular}{l}
$\sem{\blum{\diamond}} \defeq \top$ \\
$\sem{\blum{\Omega,a:q}} \defeq \sem{\blum{\Omega}}.\sem{\blum{\Omega};\blum{q}}$ if $x$ not in $\blum{\Omega}$, undefined otherwise.\\
$\sem{\blum{\Omega}; \blum{(j : q) \Rightarrow r}} \defeq \Pi(\sem{\blum{\Omega};\blum{q}},\sem{\blum{\Omega,a:q};\blum{r}})$ \\
$\sem{\blum{\Omega}; \blum{\mathbf{prf}~j}} \defeq (~[ \sem{\blum{\Omega}; \blum{j}}_\omega = \mathit{true} ]~)_{\omega \in \sem{\blum{\Omega}}}$ \\
$\sem{\blum{\Omega}; \blum{prop}} \defeq ( \{ \mathit{true}, \mathit{false} \} )_{\omega \in \sem{\blum{\Omega}}}$\\
$\sem{\blum{\Omega}; \blum{str}} \defeq (\text{the set of strings})_{\omega \in \sem{\blum{\Omega}}}$\\
$\sem{\blum{\Omega}; \blum{App_{[a:q],r}(i,j)}} \defeq$ \\
\hspace{1.5ex} $\mathit{App}_{\sem{\blum{\Omega;q}},\sem{\blum{\Omega,a:q;r}}} \circ \langle \overline{\sem{\blum{\Omega ; i}}}, \sem{\blum{\Omega ; j}}^+ \rangle_{\sem{\blum{\Omega ; \blum{(a : q) \to r}}}^+}$ \\
$\sem{\blum{\Omega,a \! : \! q}~;~\blum{a}} \defeq \frak{v}_{\sem{\blum{\Omega,a:q}}}$ \\
$\sem{\blum{\Omega};\blum{s}} \defeq \fm{s}{\omega \in \sem{\blum{\Omega}}}$
\end{tabular}{l}
\end{small}
\end{figure}

\subsection{Type language}

%\begin{figure}
%\begin{tabular}{l}
%$\sem{\{ [\blum{a : str}] : \tau \}}_\omega \gamma \defeq$ \\
%\hspace{1em} $\{ f \in \mathit{Inst} \mid f |_s \in \sem{\tau}_{(\omega,s)} \gamma^+ \text{ if } \sem{\tau}_{(\omega,s)} \gamma^+ \text{ is non-empty }$ \\
%\hspace{5.5em} $ \text{and } f |_s = \emptyset \text{ otherwise} \}$ \\~\\
%hello
%\end{tabular}
%\end{figure}

\begin{figure*}
\begin{tabular}{l}
$\sem{\{ [\blum{a : str}] : \tau \}}_\omega \gamma \defeq \{ f \mid \forall s. f |_s \in \sem{\tau}_{(\omega,s)} \gamma^+ \text{ if } \sem{\tau}_{(\omega,s)} \gamma^+ \text{ is non-empty } \text{and } f |_s = \emptyset \text{ otherwise} \}$ \\~\\
$\sem{\{ \blum{s_i} : \tau_i^{~i \in 1..n}\}}_\omega \gamma \defeq \{ f \mid \forall i \in 1..n.~f |_{s_i} \in \sem{\tau_i}_{\omega} \gamma \}$\\~\\
$\sem{\{ \blum{a : str} \mid \blum{i} \}}_\omega \gamma \defeq \{ f \mid f(\epsilon) \! \downarrow~\wedge~~~~\sem{\blum{i}}_{(\omega, f(\epsilon))} = \mathit{true} \}$\\~\\
$\sem{\bigvee \tau}_{\omega} \gamma \defeq \bigcup_{M \in \sem{\blum{q}}_\omega} (\sem{\tau}_{\omega} \gamma)_M$
\end{tabular}

\caption{Direct semantics for non-operational kinding rules}
\label{fig:kindsem-direct}
\Description[Direct semantics for non-operational kinding]{Direct semantics for non-operational kinding rules}
\end{figure*}

Our kinding and kind formation judgments are interpreted in terms of the fibration $\mathit{Fam}(\mbf{Sets})$. We assume basic knowledge of fibrations \cite{}. A kind-in-sorting-context $\blum{\Omega} \vdash \kappa$ is interpreted as an object of $\mathit{Fam}(\mbf{Sets})$ over $\sem{\blum{\Omega}}$, concretely a $\sem{\blum{\Omega}}$-indexed family of sets. For kind contexts $\Gamma = x_1:\kappa_1,\ldots,x_n : \kappa_n$, the kinding-context-in-sorting-context judgment $\blum{\Omega} \vdash \Gamma$ is interpreted as the product $\sem{\blum{\Omega} \vdash \kappa_1} \times \cdots \times \sem{\blum{\Omega} \vdash \kappa_n}$ in the fibre category $\mathit{Fam}(\mbf{Sets})_{\sem{\blum{\Omega}}}$. A kinding judgment $\blum{\Omega} \mid \Gamma \vdash \tau : \kappa$ is interpreted as a morphism of $\mathit{Fam}(\mbf{Sets})$ from $\sem{\blum{\Omega} \vdash \Gamma}$ to $\sem{\blum{\Omega} \vdash \kappa}$. 

\subsubsection{Dependent Simple Products}

\begin{figure}

\[\begin{tikzcd}
	{\mathit{Fam}(\mathbf{Sets})_\Omega} && {\mathit{Fam}(\mathbf{Sets})_\Psi} \\
	\\
	{\mathit{Fam}(\mathbf{Sets})_{\Omega.X}} && {\mathit{Fam}(\mathbf{Sets})_{\Psi . X \{ u \}}}
	\arrow["{\frak p(X)^*}"', curve={height=12pt}, from=1-1, to=3-1]
	\arrow["{\Pi_{\Omega,X}}"', curve={height=12pt}, from=3-1, to=1-1]
	\arrow["{u^*}", from=1-1, to=1-3]
	\arrow["{q(u,X)^*}"', from=3-1, to=3-3]
	\arrow["{\frak p(X \{ u \})^*}"', curve={height=12pt}, from=1-3, to=3-3]
	\arrow["{\Pi_{\Psi, X \{ u \}}}"', curve={height=12pt}, from=3-3, to=1-3]
\end{tikzcd}\]
\caption{Beck chevalley condition for dependent simple products}
\label{fig:beck-chevalley}
\Description[Beck-Chevalley condition for dependent simple products]{A Beck-Chevalley condition for dependent simple products}
\end{figure}

We define a \emph{CwF-fibration} as a pair $(\mathcal C, p)$ where $\mathcal C$ is a category-with-families and $p : \mathbb E \to \mathbb C$ is a fibration whose base category $\mathbb C$ is $\mathcal C$'s context category.

We say that a CwF-fibration has dependent simple products if 
\begin{itemize}
\item For all contexts $\Omega$ and all $X \in \mathit{St}(\Omega)$ the functor $\frak p (X)^*$ has a right adjoint $\Pi_{\Omega, X}$.
\item For every $u : \Psi \to \Omega$ and $X \in \mathit{St}(\Omega)$ the canonical natural transformation $u^* \Pi_{\Omega,X} \Longrightarrow \Pi_{\Psi, X \{ u \}} \frak q(u, X)^*$ is an isomorphism.
\end{itemize}

In the latter point, the \emph{canonical transformation} is obtained as follows. First, it is a standard fact of fibrations that for arrows $u : \Omega \to \Psi$ and $v : \Psi \to \Upsilon$ of the base category, we have $u^*v^* \cong (v \circ u)^*$. Hence we obtain \\~\\
$\frak q(u,X)^* \frak p(X)^*$\\
$\cong (\frak p(X) \circ \frak q(u,X))^*$\\ 
$= (\frak p(X) \circ \langle u \circ \frak p(X \{ u \}), \frak v_{X \{ u \}} \rangle)^*$\\
$= (u \circ \frak p(X \{ u \}))^*$\\
$= \frak p(X \{ u \})^* u^*$\\~\\
The canonical transformation is then the transpose of\\~\\
$\frak p(X \{u \}) u^* \Pi \overset{\cong}{\to} q(u,X)^* \frak p(X)^* \Pi \overset{q(u,X) \epsilon}{\to} q(u,X)^*$\\~\\


%\begin{figure}

%\begin{small}

%\begin{tabular}{l}
%(``Alonzo Church'', ``Purchases'', ``0'', ``itemId'') $\mapsto$ ``Sony Digital Paper'' \\
%(``Alonzo Church'', ``Purchases'', ``0'', ``cardId'') $\mapsto$ ``Alonzo's Card''\\
%(``Alonzo Church'', ``Cards'', ``Alonzo's Card'', ``Addr'') $\mapsto$ ``12 Main St''\\
%(``Alonzo Church'', ``Cards'', ``Alonzo's Card'', ``Type'') $\mapsto$ ``Visa''\\~\\

%(``Alan Turing'', ``Cards'', ``Alan's Card'', ``Addr'') $\mapsto$ ``312 Some Rd''\\
%(``Alan Turing'', ``Cards'', ``Alan's Card'', ``Type'') $\mapsto$ ``Mastercard''\\
%\end{tabular}

%\end{small}

%\end{figure}

%Hierarchical database schemas are often informally documented in wikis. These informal schemas can easily omit important details, 

%We use a simplified model of hierachical databases. A \emph{location} is a list of strings, and a \emph{database instance} is a partial function from lists of strings to strings. Initially, it is totally undefined, and each store defines the database at a specific  

%To demonstrate the benefits and pitfalls of hierarchical database schemas



\end{document}
