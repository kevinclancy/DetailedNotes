\documentclass[sigplan,10pt,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=true}
\bibliographystyle{ACM-Reference-Format}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{tikz}
\usepackage{quiver}
\usepackage{bussproofs}
\usepackage{amsmath}

\usetikzlibrary{cd}

\lstset{
  basicstyle=\small\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  numbers=left
}

\newcommand{\blu}[1]{\textbf{\color{blue}{#1}}}
\newcommand{\blum}[1]{\mathbf{\color{blue}{#1}}}
\newcommand{\defeq}{\overset{\mathit{def}}{=}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\fm}[2]{
\left(
\tiny
#1
\normalsize
\right)_{#2}
}

\title{Indexed Kind Checking for Hierarchical Database Schemas}
\author{Kevin Clancy}

 
\begin{document}

%\category{D.3.3}{Test 1}
%\terms{Languages}
\keywords{Indexed types, Database schemas, Dependent types}
\ccsdesc[100]{NetworksËœNetwork reliability}


\begin{abstract}

Types are an appropriate tool for describing the structure of hierarchical databases. But two common database idioms, \emph{foreign keys} and \emph{secondary indices}, cannot be expressed using standard type systems. We present a lanaguage in which a database schema is described using a type layered over a dependently sorted index language. The index language consists of keys and relations on keys. Multiple occurrences of the same index-level relation inside of a schema establish a correlation between two distinct portions of a database instance; both secondary indices and foreign keys can be specified in this manner.

%We present a lanaguage in which a database schema is described using a type layered over a dependently sorted index language of keys and relations on keys. A dictionary type constructor binds a sequence of $n$ index variables corresponding to a sequence of $n$ nested keys. It also includes a proposition, typically an application of an $n$-ary predicate on keys, which determines the exact set of key sequences that a database instance must contain. We a reconfiguration by including the same predicate in multiple dictionary types.


\end{abstract}

\maketitle

\section{Introduction}

Programmers increasingly choose document database systems, such as DynamoDB, due to their high performance and intuitive hierarchical structure. Schemas for such databases are often intentionally omitted under the premise that they inhibit rapid iteration. However, we disagree with this premise. We believe that the arguments in favor of database schemas are analogous to those in favor of static types in programming langauges. 

The type syntax of a standard programming lanaguage such as Typescript is, for the most part, an appropriate tool to describe the structure of modern hierarchical databases. However, two common features of hierarchical databases lie beyond the reach of standard type systems. First, a database may store \emph{foreign keys}: values used to refer to entities stored elsewhere in the database. Second, a database may replicate a dataset in multiple configurations, or \emph{secondary indices}, to accomodate multiple access patterns in an efficient, spatially local manner. 

The prevalence of foreign keys in hierarchical databases constrasts sharply against the in-memory data structures one typically finds in general purpose lanaguages. A pointer in a language such as C++ is not a foreign key, because statically our concern is the type of referenced data rather than its location. In contrast, consider an e-commerce database which records purchases performed by customers. Each purchase refers to the credit card used for payment; however, this card is not drawn from a global pool of all cards, but instead the pool of cards owned by the customer which made the purchase. 

Secondary indices are also common and useful database structure beyond the reach of traditional type systems. Consider this example demonstrating the utility of secondary indices. An e-commerce company wishes to issue a recall on a product. To do so, it must obtain a list of all customers that have purchased an item known to be defective; to compute this list efficiently, the set of all customers which purchased each item must be stored in nearby addresses. At another time, a customer may wish to obtain a list of all items he has purchased from the site; to perform this operation efficiently, we must store the set of all of a customer's purchased items in nearby addresses. These two requirements are at odds if our database merely stores a single collection of all purchases processed. However, if we redundantly store customer-to-item and item-to-customers map, we can satisfy both requirements at once. Such redundant data structures are called secondary indices.

In practice, foreign keys often refer to deleted entities. Such a foreign key is a time-bomb which will raise an exception the next time the data is accessed. Secondary indices can become out-of-sync due to programmer errors. A formal schema language including notions of foreign keys and indices could be compiled to validation routines to detect these errors. 

\begin{itemize}   
\item We develop a schema language for hierarchical databases with the ability to express foreign keys and secondary indices. 
\item blah blah blah denotational semantics (and operational)
\end{itemize}

Since we are working with two distinct concepts which are both typically referred to as \emph{indices} -- indices in the sense of database indices and indices in the sense of indexed type checking -- we refer to database secondary indices as \emph{reconfigurations} in the sequel.

%Likewise, we don't have 
%Chronicles indexing on pg 9040.


%\pagebreak


\section{Example}


%The schema begins with some predicate declarations. On the first line, 
%``\verb!(ItemId : str -> prop) =>!'' binds a predicate scoped over the rest of the schema fragment. 
%This forms an index-to-type abstraction mapping each unary predicate on strings to a schema.  

%NewMiscStudy pg 9047 describes chronicles indices.

\subsection{Foreign Keys}

\begin{figure}

\begin{lstlisting}[escapeinside=`']
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{ItemId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CustId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{PurchaseId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CardType : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CardId : (x:str) -> prf (CustId x) -> str -> prop}').

type Card = {
  billingAddr : str
  cardType    : { `\blu{x : str}' | `\blu{CardType x}' }
}

type Purchase = `$\lambda$(\blu{cust : str}).$\lambda$(\blu{prf (CustId cust)}).' {
  itemId : { `\blu{x : str}' | `\blu{ItemId x}' }, 
  cardId : { `\blu{x : str}' | `\blu{CardId cust x}' }
}

type Customer = `$\lambda$(\blu{cust : str}).$\lambda$(\blu{prf (CustId cust)}).' { 
  purchases : { 
    [`\blu{p : str}'] : `\blu{PurchaseId p}' > Purchase `\blu{cust}' 
  },
  cards     : { 
    [`\blu{card : str}'] : `\blu{CardId cust card}' > Card 
  }
}

{
  cardTypes : { [`\blu{x : str}'] : `\blu{CardType x}' > "*" }
  customers : { [`\blu{x : str}'] : `\blu{CustId x}' > Customer `\blu{x}'}
}
\end{lstlisting}

\caption{Schema for e-commerce database with foreign keys}
\label{fig:ecommerce}
\end{figure}

The purpose of a schema is to identify a set of database instances, so before examining our first schema we briefly define some formalisms for describing database instances. We consider \emph{database instances} (also called \emph{instances}) as partial mappings from lists of strings to strings. Given a database instance $f$, and a list of strings $\sigma$, we obtain $f |_\sigma$, \emph{the restriction of $f$ to $\sigma$}, defined for lists $\sigma'$ as $f |_\sigma(\sigma') \defeq f(\sigma + \! \! +~\sigma')$, where $\sigma + \! \! +~ \sigma'$ is the concatenation of $\sigma$ and $\sigma'$. By an abuse of language, we say ``$f$ maps $\sigma$ to $f |_{\sigma}$''. We write $[s_1, \ldots, s_n]$ for the list containing the $n$ strings $s_1,\ldots,s_n$. 

Figure \ref{fig:ecommerce} shows a schema fragment for an e-commerce database. It begins by declaring five predicates: first four unary predicates for item ids, customer ids, purchase ids, and card types. Finally, it declares a ternary predicate for card ids. The predicate variables and their classifiers have been bolded and colored blue to indicate that they are part of the \emph{index language}. This simple language defines conceptual entities such as predicates and relations, divorced from the physical details of where these entities are stored. The index langauge is layered beneath our schema language, i.e. schemas may depend on indices but not vice versa. 

Lines 7-10, use the record type constructor to define a subschema representing credit cards. It denotes the set of instances which map the list [``addr''] to any string and the list [``cardType''] to any string satisfying the \lstinline[mathescape]{$\blu{CardType}$} predicate. 

%The field \emph{cardId} is an instance of a foreign key. In this schema language, foreign keys don't refer directly to locations in the database; instead, they refer to index-level unary predicates. By separating conceptual sets (index-level predicates) from their physical  

Lines 12-15 define an index-to-type operator called \emph{Purchase}, which maps a string \lstinline[mathescape]{$\blu{cust}$} and a proof that \lstinline[mathescape]{$\blu{cust}$} satisfies the \lstinline[mathescape]{$\blu{CustId}$} predicate to a type denoting representing purchases made by customer \lstinline[mathescape]{$\blu{cust}$}. In the application \lstinline[mathescape]{$\blu{CardId cust card}$}, the second argument to  \lstinline[mathescape]{CardId} is missing. This is because it is a proof; since any two proofs of the same proposition are interchangeable, we apply proofs implicitly to reduce visual clutter. 

On lines 17-24 define a index-to-type operator \lstinline{Customer} mapping a string \lstinline[mathescape]{$\blu{cust}$} and a proof that \lstinline[mathescape]{$\blu{CustId cust}$} holds to a type representing customers with id \lstinline[mathescape]{$\blu{cust}$}. It denotes the set of instances which
\begin{itemize}
\item Map all lists [``purchases'', \lstinline[mathescape]{$\blu{p}$}] such that \lstinline[mathescape]{$\blu{purchaseId p}$} holds to instances of type \lstinline[mathescape]{Purchase $\blu{cust}$}. 
\item Map all lists [``cards'', \lstinline[mathescape]{$\blu{card}$}] such that \lstinline[mathescape]{$\blu{CardId cust card}$} holds to instances of type \lstinline{Card}.
\end{itemize}

Finally, lines 26-29 define the schema using a record type. It denotes the set of instances which: 
\begin{itemize}
\item Map [``cardTypes''] to a subinstance that stores the set of all card types by mapping each \lstinline[mathescape]{Purchase $\blu{x}$} satisfying the \lstinline[mathescape]{$\blu{CardType}$} predicate to the string \lstinline[mathescape]{"*"}
\item Map [``customers''] to a dictionary that maps every \lstinline[mathescape]{$\blu{x}$} satisfying the \lstinline[mathescape]{$\blu{CustId}$} predicate to a subschema of type \lstinline[mathescape]{Customer $\blu{x}$}. 
\end{itemize}

%The code \lstinline[mathescape]{$\lambda (\blu{ItemId : str -> prop})/$} on the first line is an abstraction mapping indices of sort \lstinline[mathescape]{$\blu{str -> prop}$} to the type whose syntax occupies the remaining lines of the figure. A type denotes a set of database instances.

\subsection*{Reconfigurations}


\begin{figure} 

\begin{small}
\begin{lstlisting}[escapeinside=`']
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{ItemId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CustId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{Purchased : \\ \hspace{1cm} (x : str) -> prf (CustId x) -> \\ \hspace{1cm} (y : str) -> prf (ItemId y) -> prop}').

{ 
  custToItem : { 
    [`\blu{c,i : str}'] : `\blu{CustId c}, 
                           \blu{ItemId i}, 
                           \blu{Purchased c i}' > "*" 
  }
  itemToCust : { 
    [`\blu{i,c : str}'] : `\blu{CustId c}, 
                           \blu{ItemId i}, 
                           \blu{Purchased c i}' > "*"
  }
}
\end{lstlisting}

\end{small}
\caption{Reconfigurations (secondary indices) in an e-commerce database}
\label{fig:ecommerce-indices}
\Description[Secondary indices]{Secondary indices in an e-commerce database}
\end{figure}

Figure \ref{fig:ecommerce-indices} shows a schema for a simple database with reconfigurations. An instance satisfies the schema if 
\begin{itemize}
\item For each customer/item pair \lstinline[mathescape]{$\blu{c}$}, \lstinline[mathescape]{$\blu{i}$} satisfying \lstinline[mathescape]{$\blu{Purchased c i}$}, it maps \lstinline[mathescape]{["custToItem", $\blu{c}$, $\blu{i}$]} to the string \lstinline[mathescape]{"*"} and \lstinline[mathescape]{["itemToCust", $\blu{i}$, $\blu{c}$]} to \lstinline[mathescape]{"*"}.
\item It is not defined anywhere else.
\end{itemize}

Such an instance allows us to efficiently query both the set of all items purchased by a customer (via \lstinline[mathescape]{custToItem}) and the set of all customers which purchased an item (via \lstinline[mathescape]{itemToCust}). Importantly, the two fields both refer to the same set of purchase entities via the index-level relation \lstinline[mathescape]{$\blu{Purchased}$}.

\section{Syntax}

\iffalse

\begin{tabular}{llll}
$\mathit{Chars}$ & $\doteq$ & the set of all characters \\
$\mathit{TypeVars}$ & $\doteq$ & the set of all type variables \\
$\mathit{IndexVars}$ & $\doteq$ & the set of all index variables \\
$x,y,z$ & $\in$ & $\mathit{TypeVars}$ & ~ \\
$\blu{a}, \blu{b}, \blu{P}$ & $\in$ & $\mathit{IndexVars}$ & ~ \\
$\blu{c}$ & $\in$ & $\mathit{Chars}$ & (characters) \\
$\blu{s},\blu{t}$ & $\in$ & $\mathit{Strings}$ & (where $\mathit{Strings} = \mathit{Chars}^{\star}$) \\~\\
 & & \\
$\blu{j},\blu{k}$ (index) & ::=  & $\blu{s}$ & (string literal) \\
                          & $\mid$ & $\blu{App_{[a : q],p}(j,k)}$ & (index application) \\
                          & $\mid$ & $\blu{a}$ & (index variable) \\~\\
$\blu{C}$ (string classifiers) & ::= & $\blu{s}$ & (string singleton) \\
                         & $\mid$ & $\blu{str}$ & (all strings) \\~\\
$\blu{q},\blu{r}$ (sort) & ::= & $\blu{C}$ & (sort of strings satisfying $C$) \\
                         & $\mid$ & $\blu{\textbf{prop}}$ & (proposition sort) \\
                         & $\mid$ & $\blu{\textbf{prf}~\phi}$ & (proof sort) \\
                         & $\mid$ & $\blu{(a : q) \Rightarrow r}$ & (dependent function sort) \\~\\
$\kappa,\rho$ (kind) & $::=$ & $\ast$ & (kind of proper types) \\
                     & $\mid$ & $\kappa \to \rho$ & (type-to-type operator)\\
                     & $\mid$ & $\forall \blu{q}.~\kappa$ & (index-to-type operator) \\~\\
$\tau,\sigma$ (type) & $::=$ & $\{[\blu{a : C}] : \tau \}$ & (dictionary type) \\ 
       & $\mid$ & $\{ \blu{s}_i : \tau_i^{~i \in 1..n} \}$ & (record type) \\
       & $\mid$ & $\langle \blu{C} \rangle$ & (string type) \\
       & $\mid$ & $\lambda \blu{a : q} . \tau$ & (index-to-type abstraction) \\
       & $\mid$ & $\lambda x : \kappa. \tau$ & (type-to-type abstraction) \\
       & $\mid$ & $\bigvee \tau$ & (colimit) \\
       & $\mid$ & $\tau~\sigma$ & (type application) \\
       & $\mid$ & $\tau~[~\blu{j}~]$ & (index-to-type application)
\end{tabular}

\fi 

\begin{figure}
\begin{tabular}{llll}
$\mathit{TypeVars}$ & $\defeq$ & the set of all type variables \\
$\mathit{IndexVars}$ & $\defeq$ & the set of all index variables \\
$x,y,z$ & $\in$ & $\mathit{TypeVars}$ & ~ \\
$\blu{a}, \blu{b}, \blu{P}$ & $\in$ & $\mathit{IndexVars}$ & ~ \\
$\blu{s},\blu{t}$ & $\in$ & $\mathit{Strings}$ & ~ \\
\end{tabular}\\~\\~\\
\begin{tabular}{llll}
$\blu{i},\blu{j},\blu{k}$ (indices) & ::=  & $\blum{s}$ & (string literal) \\
                          & $\mid$ & $\blum{App}_{\blum{[a : q],p}}\blum{(j,k)}$ & (index application) \\
                          & $\mid$ & $\blu{a}$ & (index variable) \\
                          & $\mid$ & $\blu{true}$ & (true proposition) \\
~ & ~ & ~ & ~ \\
$\blu{q},\blu{r}$ (sort) & ::= & $\blum{str}$ & (string sort) \\
                         & $\mid$ & $\blum{prop}$ & (proposition sort) \\
                         & $\mid$ & $\blum{prf~j}$ & (proof sort) \\
                         & $\mid$ & $\blum{(a : q) \to r}$ & (function sort) \\
~ & ~ & ~ & ~ \\
$\tau,\sigma$ (type) & $::=$ & $\{[\blu{a : str}] : \tau \}$ & (dictionary type) \\ 
       & $\mid$ & $\{ \blu{s}_i : \tau_i^{~i \in 1..n} \}$ & (record type) \\
       & $\mid$ & $\{ \blu{a : str} \mid \blu{i} \}$ & (string refinement type) \\
       & $\mid$ & $\lambda \blu{a : q} . \tau$ & (index-to-type abstr.) \\
       & $\mid$ & $\lambda x : \kappa. \tau$ & (type-to-type abstr.) \\
       & $\mid$ & $\bigvee \tau$ & (union) \\
       & $\mid$ & $\tau~\sigma$ & (type app.) \\
       & $\mid$ & $\tau~[~\blu{j}~]$ & (index-to-type app.)\\
~ & ~ & ~ & ~ \\
$\kappa,\rho$ (kind) & $::=$ & $\ast$ & (proper type kind) \\
                     & $\mid$ & $\kappa \to \rho$ & (type-to-type op)\\
                     & $\mid$ & $\forall \blu{q}.~\kappa$ & (index-to-type op)
\end{tabular}\\~\\~\\
\begin{tabular}{llll}
$\blum{\Omega}, \blum{\Psi}$ (pre-index-context) & $::=$  & $\blum{\Omega,a : q}$ & (extension) \\
                                     & $\mid$ & $\blum{\diamond}$ & (empty) \\~\\
$\Gamma$ (kind context) & $::=$ & $\Gamma,x : \kappa$ & (extension) \\
                        & $\mid$ & $\diamond$ & (empty) 
\end{tabular}
\caption{Syntax}
\label{fig:syntax}
\Description[Syntax]{Syntax}
\end{figure}

Index-level terms $\blum{i,j,k}$ consist of string literals, variables, applications, and the proposition constant $\blum{true}$. An application is annotated with the domain and codomain of the applied function; this eases the definition of our denotational semantics, but the types can be inferred and are thus omitted in our examples, which instead use the notation $\blum{j}~\blum{k}$ as shorthand for $\blum{App_{[a : q], p}(j,k)}$.

Following \cite{dependent ml journal of fp}, index level classifiers are called \emph{sorts}. Sorts are written using the variables $\blum{p,q,r}$. We include the sorts $\blum{str}$ for strings, $\blum{prop}$ for propositions, $\blum{prf}~j$ proofs of the proposition $\blum{j}$, and the sort constructor $\blum{(a : q) \to r}$ for constructing dependen function sorts, which are essentially index-level $\Pi$-types.

Our types $\tau,\sigma$ are also called \emph{schemas}. The type constructor $\{ [\blum{a : str}] : \tau \}$ is used for dictionaries of value type $\tau$. The type $\tau$ depends on the index variable $\blum{a}$, and such a dictionary type describes the set of database instances which contains exactly those keys $\blum{a}$ which $\tau$ maps to a non-empty set of database instances. The record types, type-type applications, and type-type abstractions in our type syntax are standard. A string refinement type of the form $\{ \blum{a : str} \mid \blum{i} \}$ denotes the set of all strings which satisfy the proposition $\blum{i}$.

Finally, our type syntax include index-type abstractions $\lambda (\blum{a : q}). \tau$, index-type application $\tau~[~\blum{j}~]$, and union $\bigvee \tau$. In a well-kinded union type $\bigvee \tau$, the type $\tau$ is an index-type function whose codomain is $\ast$ (the kind of proper types). $\tau$ then denotes a function which maps a semantic index to a set of database instances; $\bigvee \tau$ denotes the union over the applications of $\tau$ to all semantic indices in its domain. 
   
In figures \ref{fig:ecommerce} and \ref{fig:reconfigurations}, a dictionary type of the form $\{ [\blum{a :str}] : \blum{i_1, \ldots, i_n} > \tau \}$ is sugar for $$\{ [\blum{a :str}] : \bigvee \lambda \blum{(a_1 : prf~i_1}) \ldots \bigvee \lambda (\blum{a_n : prf~i_n}). \tau \}$$

\section{Static classification}

\subsection{Sorting}

\begin{figure}
\begin{mathpar}
\inferrule
  {~}
  {\blum{\Omega \vdash s : str}}
\and
\inferrule
  {~}
  {\blum{\Omega,a : q, \Omega' \vdash a : q}}
\and
\inferrule
  {\blum{\Omega \vdash j : (a : q) \to r} \\ \blum{\Omega \vdash k : q}}
  {\blum{\Omega \vdash App_{[a : q],r}(j,k) : r[k/a]}}
\and
\inferrule
  {~}
  {\blum{\Omega \vdash true : prop}}
\and
\inferrule
  {~}
  {\blum{\Omega \vdash str}}
\and
\inferrule
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a:q \vdash r}}
  {\blum{\Omega \vdash (a : q) \Rightarrow r}}
\and
\inferrule
  {\blum{\Omega \vdash j : prop}}
  {\blum{\Omega \vdash prf~j}}
\and
\inferrule
  {~}
  {\blum{\diamond \vdash}}
\and
\inferrule
  {\blum{\Omega \vdash} \\ \blum{\Omega \vdash p}}
  {\blum{\Omega, a : p \vdash}}
\end{mathpar}
\caption{Sorting, sort formation, and sort context formation}
\label{fig:sorting}
\Description[Sorting and sort formation]{Sorting and sort formation rules}
\end{figure}

Here are some sorting and sort formation rules.

\subsection{Kinding}

Here are some kinding and kind formation rules.

\begin{figure}
\begin{mathpar}
\inferrule
  {\blum{\Omega,a : str} \mid \Gamma \vdash \tau : \ast}
  {\blum{\Omega} \mid \Gamma \vdash \{ [\blum{a : str}] : \tau \} : \ast}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau_i : \ast^{~i \in 1..n}}
  {\blum{\Omega} \mid \Gamma \vdash \{ \blum{s}_i : \tau_i^{~i \in 1..n} \} : \ast}
\and
\inferrule
  {\blum{\Omega,a:str \vdash i : prop}}
  {\blum{\Omega} \mid \Gamma \vdash \{ \blum{a : str} \mid \blum{i} \} : \ast}
\and
\inferrule
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a : q} \mid \Gamma \vdash \tau : \kappa \\ a \not \in FV(\Gamma)}
  {\blum{\Omega} \mid \Gamma \vdash \lambda \blum{a : q} . \tau : \forall \blum{q} . \kappa}
\and
\inferrule
  {\blum{\Omega} \vdash \kappa \\ \blum{\Omega} \mid \Gamma,x:\kappa \vdash \tau : \rho}
  {\blum{\Omega} \mid \Gamma \vdash \lambda x : \kappa. \tau : \kappa \to \rho}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \forall \blum{q}. \ast}
  {\blum{\Omega} \mid \Gamma \vdash \bigvee \tau : \ast}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \forall \blum{q}. \rho \\ \blum{\Omega \vdash j : q}}
  {\blum{\Omega} \mid \Gamma \vdash \tau~[~\blum{j}~]: \rho}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \kappa \to \rho \\ \blum{\Omega} \mid \Gamma \vdash \sigma : \kappa}
  {\blum{\Omega} \mid \Gamma \vdash \tau~\sigma : \rho}
\and
\inferrule
  {~}
  {\blum{\Omega} \vdash \ast}
\and
\inferrule
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a:q} \vdash \kappa}
  {\blum{\Omega} \vdash \forall \blu{q}. \kappa}
\and
\inferrule
  {\blum{\Omega} \vdash \kappa \\ \blum{\Omega} \vdash \rho}
  {\blum{\Omega} \vdash \kappa \to \rho}
\and
\inferrule
  {~}
  {\blum{\Omega} \vdash \diamond}
\and
\inferrule
  {\blum{\Omega} \vdash \Gamma \\ \blum{\Omega} \vdash \kappa}
  {\blum{\Omega} \vdash \Gamma, x : \kappa}
\end{mathpar}
\caption{Kinding and kind formation}
\label{fig:kinding}
\Description[Kinding and kind formation]{Kinding, kind formation, and kind context formation rules}
\end{figure}

\section{Denotational Semantics}

\subsection{Index Language}

We interpret our index langauage using Dybjer's \emph{Categories-with-Families} (CwF) framework for semantically modeling dependently typed languages \cite{}. We first review the definition of CwF, then review the standard set-theoretic CwF, and finally provide an interpretation of the index language with respect to a CwF. There is nothing novel about our index language, so the entirety of this section is standard. However, we rename some of the standard terminology to fit into the present setting, e.g. instead of dependent types we have dependent sorts.

\subsubsection{Categories with Families}

A Category-with-Families (CwF) consists of 
\begin{itemize}
\item A category $\mathbb C$ with a terminal object, called the \emph{category of contexts}. Objects of $\mathbb C$ are called semantic contexts and written with the symbols $\Omega$, $\Psi$, $\Upsilon$.
\item For each semantic context $\Omega$ a collection $\mathit{St}(\Omega)$ called the \emph{semantic sorts} of $\Omega$. Semantic sorts are written with the symbols $X$,$Y$, and $Z$.
\item For each semantic context $\Omega$ and $X \in \mathit{St}(\Omega)$ a collection $\mathit{In}(\Omega,X)$ called the \emph{semantic indices} of sort $X$.
\item For each arrow $f : \Omega \to \Psi$ a mapping $- \{ f \} : \mathit{St}(\Psi) \to \mathit{St}(\Omega)$. These mappings preserve composition, in the sense that we have $- \{ \mathit{id}_{\Omega} \} = \mathit{id}_{\mathit{St}(\Omega)}$, and for $g : \Psi \to \Upsilon$ we have $- \{ g \circ f \} = - \{ g \} \{ f \}$.
\item For each arrow $f : \Omega \to \Psi$ and sort $X \in \mathit{St}(\Psi)$ a mapping $- \{ f \} : \mathit{In}(\Psi,X) \to \mathit{In}(\Omega,X \{ f \})$. These mappings preserve composition in the same sense as above.
\item For each context $\Omega$ and sort $X \in \mathit{St}(\Omega)$, we have an object $\Omega . X$ of $\mathbb C$, an arrow $\frak p(X) : \Omega . X \to \Omega$, and an index $\frak v_{X} \in \mathit{In}(\Omega . X, X \{ \frak p(X) \})$ such that for all $f : \Psi \to \Omega$ and $M \in \mathit{In}(\Psi, X \{ f \})$ there exists a unique morphism $\langle f , M \rangle_X : \Psi \to \Omega . X$ such that $\frak p(X) \circ \langle f , M \rangle_X = f$ and $\frak v_{X} \{ \langle f, M \rangle_X \} = M$.
\end{itemize}

For $M \in \mathit{In}(\Omega, X)$ we write $\overline{M}$ for the arrow $\langle \mathit{id}_{\Omega}, M \rangle_X : \Omega \to \Omega.X$. 

For $f : \Psi \to \Omega$ and $X \in \mathit{St}(\Omega)$ we define $\frak q(f, X) : \Psi.X \{ f \} \to \Omega . X$, called the \emph{weakening} $f$ by $X$ as
$$\frak q(f,X) = \langle f \circ \frak p(X \{ f \}), \frak v_{X \{ f \}} \rangle_X$$

A \emph{weakening map} is a morphism of the form $\frak p(X) : \Omega . X \to \Omega$ or of the form $\frak q(w, Y)$ where $w$ is a weakening map. We write $f^+$ and $X^+$ for $f \{ w \}$ and $X \{ w \}$ when $w$ is a weakening map that is clear from context.

A CwF is said to \emph{support $\Pi$-sorts} if for any two sorts $X \in \mathit{St}(\Omega)$ and $Y \in \mathit{St}(\Omega.X)$ there is a sort $\Pi(X,Y) \in \mathit{St}(\Omega)$ and a morphism $$\mathit{App}_{X,Y} : \Omega . X . \Pi(X,Y)^+ \to \Omega . X . Y$$ such that $$\frak p(X) \circ \mathit{App}_{X,Y} = \frak p(\Pi(X,Y)^+) \hspace{3.0ex} \textit{App-T}$$
and for every $M \in \mathit{In}(\Omega.X, Y)$
$$\mathit{App}_{X,Y} \circ \overline{M \{ p(X) \}} = \overline{M} \hspace{3.0ex} \Pi\textit{-C'}$$
and for every morphism $f : B \to \Gamma$\\~\\
$\mathit{App}_{X,Y} \circ \frak q( \frak q(f, X), \Pi(X,Y)\{ \frak q (f, X) \})$\\ 
$= \frak q(\frak q (f, X), Y) \circ \mathit{App}_{X \{ f \}, Y \{ \frak q(f, \sigma) \}}$\\~\\

\subsubsection{Set-theoretic CwF}

Our index language will be interpreted using a standard set-theoretic CwF. This CwF's category of contexts is $\mbf{Sets}$, the category of sets and functions. For a set $\Omega$, $\mathit{St}(\Omega)$ is the collection of all $\Omega$-indexed families of sets. For all $\Omega$ and $X \in \mathit{St}(\Omega)$, $\mathit{In}(\Omega,X)$ is the collection of families $\fm{x_\omega \in X_\omega}{\omega \in \Omega}$ selecting an element $x_\omega \in X_\omega$ for each $\omega \in \Omega$. For all $h : \Omega \to \Psi$, $X \in \mathit{St}(\Psi)$, and $M \in \mathit{In}(\Psi,X)$ we define $X \{ h \}_{\omega} \defeq X_{f(\omega)}$ and $M \{ h \}_\omega \defeq M_{f(\omega)}$. For each $\Omega$ and $X \in \mathit{St}(\Omega)$ we define $$\Omega . X \defeq \{ (\omega,x) \mid \omega \in \Omega \text{ and } x \in X_\omega \}$$ $\frak p (X)(\omega,x) \defeq \omega$, and $(\frak v_{X})_{(\omega,x)} \defeq x$. Finally, letting $f : \Psi \to \Omega$ and $M \in \mathit{In}(\Psi, X \{ f \})$, we have $\langle f, M \rangle_X(\psi) = (f(\psi), M_{\psi})$.

\subsubsection{Interpretation}

Our index langauge is a fragment of the calculus of constructions, with the unnotable addition of strings. Its interpretation appears, for example, in \cite{}, and is displayed in Figure \ref{fig:index-interp} for convenience. 

\begin{figure}
\begin{small}
\begin{tabular}{l}
$\sem{\blum{\diamond}} \defeq \top$ \\
$\sem{\blum{\Omega,a:q}} \defeq \sem{\blum{\Omega}}.\sem{\blum{\Omega};\blum{q}}$ if $x$ not in $\blum{\Omega}$, undefined otherwise.\\
$\sem{\blum{\Omega}; \blum{(j : q) \Rightarrow r}} \defeq \Pi(\sem{\blum{\Omega};\blum{q}},\sem{\blum{\Omega,a:q};\blum{r}})$ \\
$\sem{\blum{\Omega}; \blum{\mathbf{prf}~j}} \defeq (~\{ \ast \} \text{ if } \sem{\blum{\Omega}; \blum{j}}_\omega = \mathit{true}, \text{~}\emptyset\text{ otherwise}~)_{\omega \in \sem{\blum{\Omega}}}$ \\
$\sem{\blum{\Omega}; \blum{prop}} \defeq ( \{ \mathit{true}, \mathit{false} \} )_{\omega \in \sem{\blum{\Omega}}}$\\
$\sem{\blum{\Omega}; \blum{str}} \defeq (\text{the set of strings})_{\omega \in \sem{\blum{\Omega}}}$\\
$\sem{\blum{\Omega}; \blum{App_{[a:q],r}(i,j)}} \defeq$ \\
\hspace{1.5ex} $\mathit{App}_{\sem{\blum{\Omega;q}},\sem{\blum{\Omega,a:q;r}}} \circ \langle \overline{\sem{\blum{\Omega ; i}}}, \sem{\blum{\Omega ; j}}^+ \rangle_{\sem{\blum{\Omega ; \blum{(a : q) \to r}}}^+}$ \\
$\sem{\blum{\Omega,a \! : \! q}~;~\blum{a}} \defeq \frak{v}_{\sem{\blum{\Omega,a:q}}}$ \\
$\sem{\blum{\Omega};\blum{s}} \defeq \fm{s}{\omega \in \sem{\blum{\Omega}}}$
\end{tabular}{l}
\end{small}
\caption{Interpretation of index language}
\label{fig:index-interp}
\end{figure}

We also state the fragment of the standard soundness theorem which will be relevant in the sequel. 

\begin{theorem} Our interpretation satisfies the following properties.
\begin{itemize}
\item If $\blum{\Omega \vdash}$ then $\sem{\blum{\Omega}}$ is an object of the context category $\mathbf{Sets}$.
\item If $\blum{\Omega \vdash q}$ then $\sem{\blum{\Omega};\blum{q}}$ is an element of $\mathit{St}(\sem{\blum{\Omega}})$
\item If $\blum{\Omega \vdash j : q}$ then $\sem{\blum{\Omega ; j}}$ is an element of $\mathit{In}(\sem{\blum{\Omega}}, \sem{\blum{\Omega ; q}})$
\end{itemize}
\end{theorem}

\subsection{Type language}

%\begin{figure}
%\begin{tabular}{l}
%$\sem{\{ [\blum{a : str}] : \tau \}}_\omega \gamma \defeq$ \\
%\hspace{1em} $\{ f \in \mathit{Inst} \mid f |_s \in \sem{\tau}_{(\omega,s)} \gamma^+ \text{ if } \sem{\tau}_{(\omega,s)} \gamma^+ \text{ is non-empty }$ \\
%\hspace{5.5em} $ \text{and } f |_s = \emptyset \text{ otherwise} \}$ \\~\\
%hello
%\end{tabular}
%\end{figure}

\begin{figure}
\begin{tabular}{l}
$\sem{\blum{\Omega} \vdash \ast}_\omega \defeq \mathcal P \mathcal P (\mathit{Inst})$\\
$\sem{\blum{\Omega} \vdash \forall \blum{q}. \kappa} \defeq \Pi_{\blum{\Omega},\blum{q}} \sem{\blum{\Omega, a : q} \vdash \kappa}$\\
$\sem{\blum{\Omega} \vdash \kappa \to \rho} \defeq \sem{\blum{\Omega} \vdash \kappa} \Rightarrow \sem{\blum{\Omega} \vdash \rho}$
\end{tabular}
\end{figure}

\begin{figure*}
\begin{tabular}{l}
$\sem{\{ [\blum{a : str}] : \tau \}}_\omega \gamma \defeq \{ f \mid \forall s. f |_s \in \sem{\tau}_{(\omega,s)} \gamma^+ \text{ if } \sem{\tau}_{(\omega,s)} \gamma^+ \text{ is non-empty } \text{and } f |_s = \emptyset \text{ otherwise} \}$ \\~\\
$\sem{\{ \blum{s_i} : \tau_i^{~i \in 1..n}\}}_\omega \gamma \defeq \{ f \mid \forall i \in 1..n.~f |_{s_i} \in \sem{\tau_i}_{\omega} \gamma \}$\\~\\
$\sem{\{ \blum{a : str} \mid \blum{i} \}}_\omega \gamma \defeq \{ f \mid f(\epsilon) \! \downarrow~\wedge~~~~\sem{\blum{i}}_{(\omega, f(\epsilon))} = \mathit{true} \}$\\~\\
$\sem{\bigvee \tau}_{\omega} \gamma \defeq \bigcup_{M \in \sem{\blum{q}}_\omega} (\sem{\tau}_{\omega} \gamma)_M$
\end{tabular}

\caption{Semantics for ``non-operational'' kinding rules}
\label{fig:kindsem-direct}
\Description[Direct semantics for non-operational constructs]{Direct semantics for non-operational kinding rules}
\end{figure*}

\begin{figure}
\begin{mathpar}
\inferrule
  {f \defeq \sem{\blum{\Omega} \mid \Gamma \vdash \tau : \forall \blum{q}. \rho} : \sem{\blum{\Omega \vdash \Gamma}} \to \Pi_{\blum{\Omega}, \blum{q}} \sem{\blum{\Omega, a : q} \vdash \rho} \\ M \defeq \sem{\blum{\Omega \vdash j : q}} \in \mathit{In}(\sem{\blum{\Omega}}, \sem{\blum{\Omega \vdash q}})}
  {\sem{\blum{\Omega} \mid \Gamma \vdash \tau~[~\blum{j}~] : \rho} \defeq \overline{M}^{~*}(f^\flat)}
\and
\inferrule
  {X \defeq \sem{\blum{\Omega \vdash q}} \in \mathit{St}(\Omega) \\ 
   f \defeq \sem{\blum{\Omega,a:q} \mid \Gamma \vdash \tau : \kappa} : \frak p (X)^* \sem{\blum{\Omega} \vdash \Gamma} \to\sem{\blum{\Omega,a : q} \vdash \kappa}}
  {\sem{\blum{\Omega} \mid \Gamma \vdash \lambda \blum{a : q}. \tau : \forall \blum{q}. \kappa} \defeq 
   f^\sharp}
\end{mathpar} 

\caption{Semantics for abstraction and application}
\end{figure}

Our kinding and kind formation judgments are interpreted in terms of the fibration $\mathit{Fam}(\mbf{Sets})$. We assume basic knowledge of fibrations \cite{}. A kind-in-sorting-context $\blum{\Omega} \vdash \kappa$ is interpreted as an object of $\mathit{Fam}(\mbf{Sets})_{\sem{\blum{\Omega}}}$, concretely a $\sem{\blum{\Omega}}$-indexed family of sets. For kind contexts $\Gamma = x_1:\kappa_1,\ldots,x_n : \kappa_n$, the kinding context formation judgment $\blum{\Omega} \vdash \Gamma$ is interpreted as the product $\sem{\blum{\Omega} \vdash \kappa_1} \times \cdots \times \sem{\blum{\Omega} \vdash \kappa_n}$ in $\mathit{Fam}(\mbf{Sets})_{\sem{\blum{\Omega}}}$. A kinding judgment $\blum{\Omega} \mid \Gamma \vdash \tau : \kappa$ is interpreted as a arrow of $\mathit{Fam}(\mbf{Sets})_{\sem{\blum{\Omega}}}$ from $\sem{\blum{\Omega} \vdash \Gamma}$ to $\sem{\blum{\Omega} \vdash \kappa}$. 

\subsubsection{Dependent Simple Products}

\begin{figure}

\[\begin{tikzcd}
	{\mathbb E_\Omega} && {\mathbb E_\Psi} \\
	\\
	{\mathbb E_{\Omega.X}} && {\mathbb E_{\Psi . X \{ u \}}}
	\arrow["{\frak p(X)^*}"', curve={height=12pt}, from=1-1, to=3-1]
	\arrow["{\Pi_{X}}"', curve={height=12pt}, from=3-1, to=1-1]
	\arrow["{u^*}", from=1-1, to=1-3]
	\arrow["{\frak q(u,X)^*}"', from=3-1, to=3-3]
	\arrow["{\frak p(X \{ u \})^*}"', curve={height=12pt}, from=1-3, to=3-3]
	\arrow["{\Pi_{X \{ u \}}}"', curve={height=12pt}, from=3-3, to=1-3]
\end{tikzcd}\]
\caption{Some components of Beck-Chevalley for dependent simple products}
\label{fig:beck-chevalley}
\Description[Beck-Chevalley condition for dependent simple products]{A Beck-Chevalley condition for dependent simple products}
\end{figure}

We define a \emph{CwF-fibration} as a pair $(\mathcal C, p)$ where $\mathcal C$ is a CwF and $p : \mathbb E \to \mathbb C$ is a fibration whose base category $\mathbb C$ is $\mathcal C$'s context category.

We say that a CwF-fibration has \emph{dependent simple products} if 
\begin{itemize}
\item For all contexts $\Omega$ and all $X \in \mathit{St}(\Omega)$ the functor $\frak p (X)^*$ has a right adjoint $\Pi_{X}$.
\item For every $u : \Psi \to \Omega$ and $X \in \mathit{St}(\Omega)$ the canonical natural transformation $u^* \Pi_{X} \Longrightarrow \Pi_{X \{ u \}} \frak q(u, X)^*$ is an isomorphism.
\end{itemize}

In the latter point, the \emph{canonical transformation} is obtained as follows. First, it is a standard fact of fibrations that for arrows $u : \Omega \to \Psi$ and $v : \Psi \to \Upsilon$ of the base category, we have $u^*v^* \cong (v \circ u)^*$. Hence we obtain \\~\\
$\frak q(u,X)^* \frak p(X)^*$\\
$\cong (\frak p(X) \circ \frak q(u,X))^*$\\ 
$= (\frak p(X) \circ \langle u \circ \frak p(X \{ u \}), \frak v_{X \{ u \}} \rangle)^*$\\
$= (u \circ \frak p(X \{ u \}))^*$\\
$= \frak p(X \{ u \})^* u^*$\\~\\
The canonical transformation is then the transpose of\\~\\
$\frak p(X \{u \})^* u^* \Pi_X \overset{\cong}{\to} \frak q(u,X)^* \frak p(X)^* \Pi_X \overset{\frak q(u,X) \epsilon}{\to} \frak q(u,X)^*$

\subsubsection{Set-theoretic Dependent Simple Products}

In our set-theoretic model, for semantic contexts $\Omega$ and semantic sorts $X \in \mathit{St}(\Omega)$, we define $\Pi_X : \mathit{Fam}(\mbf{Sets})_{\Omega . X} \to \mathit{Fam}(\mbf{Sets})_{\Omega}$ as:\\~\\
\begin{small}
\begin{tabular}{l}
$\Pi_{X}(\fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}) \defeq \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega}$\\
$\Pi_{X} \fm{f_{(\omega,x)} : B_{(\omega,x)} \to C_{(\omega,x)}}{(\omega,x) \in \Omega .X} \defeq \fm{\Pi_{x \in X_\omega} \hspace{2.0ex} f_{(\omega,x)}}{\omega \in \Omega}$
\end{tabular}
\end{small}
We show that $\Pi_X$ is the right adjoint of $\frak p(X)^*$ in Appendix \ref{sec:beck-chevalley},
with an underlying correspondence 
\begin{prooftree}
\AxiomC{$(A_\omega)_{\omega \in \Omega} \longrightarrow \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega} = \Pi_{X} \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$}
\doubleLine
\UnaryInfC{$\frak p (X)^* \fm{A_\omega}{\omega \in \Omega} = \fm{A_\omega}{(\omega,x) \in \Omega . X} \longrightarrow \fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}$}

\end{prooftree}
From top to bottom, this bijection, which we'll call $(-)^\sharp$ takes an arrow $$\fm{\langle f_{(\omega,x)} : A_\omega \to B_{(\omega,x)} \rangle_{x \in X_\omega}}{\omega \in \Omega}$$ to $$\fm{f_{(\omega,x)} : A_\omega \to B_{(\omega,x)}}{(\omega,x) \in \Omega.X}$$
From bottom to top, $(-)^\sharp$'s inverse $(-)^\flat$ takes an arrow $$(f_{(\omega,x)} : A_\omega \to B_{(\omega,x)})_{(\omega,x) \in \Omega . X}$$ to $$\fm{\Pi_{x \in X_\omega} f_{(\omega,x)}}{\omega \in \Omega}$$ 

In this set-theoretic model, we have that $\Pi_{X \{ u \}} \frak q (u, X)^* = u^* \Pi_{X}$, and furthermore that the canonical transformation is the identity at this functor. Clearly, then, this model satisfies the Beck-Chevalley condition for dependent simple products. % double check this

\subsection{Interpretation}

Blah blah blah.

Our interpretation satisfies the following soundness theorems.


\appendix

\onecolumn

\section{The Beck-Chevalley Condition}

\label{sec:beck-chevalley}

In our set-theoretic model, the canonical natural transformation of dependent simple products is an identity and therefore satisfies the Beck-Chevalley condition. We proceed to demonstrate this.

For semantic contexts $\Omega$ and sorts $X \in \mathit{St}(\Omega)$, we define $\Pi_{X} : \mathit{Fam}(\mbf{Sets})_{\Omega . X} \to \mathit{Fam}(\mbf{Sets})_{\Omega}$ as

\begin{small}
\begin{tabular}{l}
$\Pi_{X}(\fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}) = \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega}$\\
$\Pi_{X} \fm{f_{(\omega,x)} : B_{(\omega,x)} \to C_{(\omega,x)}}{(\omega,x) \in \Omega .X} = \fm{\Pi_{x \in X_\omega} \hspace{2.0ex} f_{(\omega,x)}}{\omega \in \Omega}$
\end{tabular}
\end{small}

We have a bijection of the following form. 
\begin{prooftree}\\~\\
\AxiomC{$(A_\omega)_{\omega \in \Omega} \longrightarrow \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega} = \Pi_{X} \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$}
\doubleLine
\UnaryInfC{$\frak p (X)^* \fm{A_\omega}{\omega \in \Omega} = \fm{A_\omega}{(\omega,x) \in \Omega . X} \longrightarrow \fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}$}

\end{prooftree}~\\~\\
From top to bottom, this bijection, which we'll call $(-)^\flat$, takes an arrow $$\fm{\langle f_{(\omega,x)} : A_\omega \to B_{(\omega,x)} \rangle_{x \in X_\omega}}{\omega \in \Omega}$$ to $$\fm{f_{(\omega,x)} : A_\omega \to B_{(\omega,x)}}{(\omega,x) \in \Omega.X}$$
From bottom to top, $(-)^\flat$'s inverse $(-)^\sharp$ takes an arrow $$(f_{(\omega,x)} : A_\omega \to B_{(\omega,x)})_{(\omega,x) \in \Omega . X}$$ to $$\fm{\Pi_{x \in X_\omega} f_{(\omega,x)}}{\omega \in \Omega}$$ 

$(-)^\flat$ underlies an adjunction $\frak p(X)^* \dashv \Pi_{\Omega, X}$. To prove this, first consider an arrow $g$, where $$g = \fm{g_{\omega}}{(\omega) \in \Omega} : \fm{C_{\omega}}{\omega \in \Omega} \to \fm{A_\omega}{\omega \in \Omega}$$
and a arrow $f$ where
$$f = \fm{f_{(\omega,x)}}{(\omega,x) \in \Omega . X} : \fm{A_\omega}{(\omega,x) \in \Omega . X} \to \fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}$$
We then have\\~\\
$(f \circ \frak p^*(g))^\sharp$\\
$= ( \fm{f_{(\omega,x)} \circ g_{\omega}}{(\omega,x) \in \Omega.X} )^\sharp$\\
$= \fm{\Pi_{x \in X_{\omega}}~~~f_{(\omega,x)} \circ g_\omega}{\omega \in \Omega}$\\
$= \fm{(\Pi_{x \in X_{\omega}}~~~f_{(\omega,x)}) \circ g_\omega}{\omega \in \Omega}$\\
$= f^\sharp \circ g$\\~\\
Next, consider a arrow $f$, where
$$f = \fm{\langle f_{(\omega,x)} \rangle_{x \in X_\omega}}{\omega \in \Omega} : \fm{A_\omega}{\omega \in \Omega} \to \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega}$$
and a arrow $g$, where
$$g = \fm{g_{(\omega,x)}}{(\omega,x) \in \Omega . X} : \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X} \to \fm{D_{(\omega,x)}}{(\omega,x) \in \Omega . X}$$
We then have\\~\\
$(\Pi_{X}(g) \circ f)^\flat$\\
$= ( \fm{\langle g_{(\omega, x)} \circ f_{(\omega,x)} \rangle_{x \in X_\omega} }{\omega \in \Omega} )^\flat$\\ 
\vspace{0.5ex}$= \fm{g_{(\omega, x)} \circ f_{(\omega,x)}}{(\omega, x) \in \Omega . X}$\\
$= g \circ f^\flat$\\~\\
To obtain the counit of this bijection at component $\fm{B_{(\omega, x)}}{(\omega,x) \in \Omega.X}$, writing $\pi_x$ for the projection $\Pi_{x \in X_\omega} B_{(x,\omega)} \to B_{(x,\omega)}$, we map the identity arrow $$\fm{\langle \pi_x \rangle_{x \in X_\omega}}{\omega \in \Omega} : \Pi_X \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega} \to \Pi_X \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega}$$ through $(-)^\flat$, obtaining the counit $\epsilon$ as $$\fm{\pi_{(\omega,x')} : \Pi_{x \in X_\omega} B_{(\omega,x)} \to B_{(\omega,x')}}{(\omega,x') \in \Omega . X}$$ It is a arrow of type
$$\frak p(X)^* \Pi_X \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X} \longrightarrow \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$$

To prove the Beck-Chevalley condition, we must first concretely describe the canonical natural transformation $u^* \Pi_X \Longrightarrow \Pi_{X \{ u \}} \frak q(u,X)^*$. As a first step, we concretely describe the natural transformation
$$\frak p(X \{u \})^* u^* \Pi_X \overset{\cong}{\to} \frak q(u,X)^* \frak p(X)^* \Pi_X \overset{\frak q(u,X) \epsilon}{\to} \frak q(u,X)^*$$
at component $\fm{B_{(\omega,x)}}{(\omega,x) \in \Omega.X}$\\~\\
$\frak p(X \{ u \})^* u^* \Pi_X \fm{B_{\omega,x}}{(\omega,x) \in \Omega.X}$\\
$= \frak p(X \{ u \})^* u^* \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega}$\\
$= \frak p(X \{ u \})^* \fm{\Pi_{x \in X_{u(\psi)}} B_{(u(\psi),x)}}{\psi \in \Psi}$\\
$= \fm{\Pi_{x \in X_{u(\psi)}} B_{(u(\psi),x)}}{(\psi,x') \in \Psi . X \{ u \}}$ \\
$= \fm{\Pi_{x \in X_{\pi \langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle (\psi,x')}} B_{(\pi \langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle (\psi,x'),x)}}{(\psi,x') \in \Psi . X \{ u \}}$\\
$= \langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle^* \fm{\Pi_{x \in X_{\pi (\omega,x')}} B_{(\pi (\omega,x'),x)}}{(\omega,x') \in \Omega . X}$\\
\vspace{1.5ex} $= \langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle^* \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{(\omega,x') \in \Omega . X}$
\[\begin{tikzcd}
	{} \\
	{} \\
	\arrow["{\langle u \circ \frak p(X \{ u \}), \frak v_{X \{u \}}\rangle^*(\pi_{(\omega, x')})_{(\omega, x') \in \Omega . X}}", from=1-1, to=3-1]
\end{tikzcd}\]
$\langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle^* \fm{B_{(\omega,x')}}{(\omega,x') \in \Omega . X}$
\\~\\
The above arrow is equal to 
$$\fm{\pi_{(u(\psi),x')} : \Pi_{x \in X_{u(\psi)}} B_{(u(\psi),x)} \to B_{(u(\psi),x')}}{(\psi, x') \in \Psi . X \{ u \}}$$
Transposing gives
$$\fm{\Pi_{x' \in X_{u(\psi)}}~(\pi_{(u(\psi),x')} : (\Pi_{x \in X_{u(\psi)}} B_{(u(\psi),x)}) \to B_{(u(\psi),x')})}{\psi \in \Psi}$$
This is the identity arrow on the object 
$$\fm{\Pi_{x' \in X_{u(\psi)}} B_{(u(\psi), x')}}{\psi \in \Psi}$$
which has the following ``type signature'' 
$$\Pi_{X \{ u \}} \frak q(u, X)^* \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X} \longrightarrow u^* \Pi_X \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$$
Because it is an identity, it is clearly invertible.

\section{Substitution lemmas}

We first reproduce some standard definitions and theorems from the semantics of dependent types. These definitions and lemmas will subsequently be used to establish our own soundness proofs.
 
For pre-contexts $\blum{\Omega},\blum{\Psi}$ and pre-sorts $\blum{q},\blum{r}$ we define the expression $\mbf{P}(\blum{\Omega};\blum{p};\blum{\Psi})$ inductively by
\begin{center}

\begin{tabular}{l}
$\mbf{P}(\blum{\Omega}; \blum{q}; \blum{\diamond}) \defeq \frak p(\sem{\blum{\Omega; p}})$\\
$\mbf{P}(\blum{\Omega}; \blum{q}; \blum{\Psi,a \! : \! r}) \defeq \frak q (\mbf{P}(\blum{\Omega} ; \blum{q} ; \blum{\Psi}),\sem{\blum{\Omega},\blum{\Psi};\blum{r}})$
\end{tabular}
\end{center}

The idea is that $\mbf{P}(\blum{\Omega} ; \blum{q} ; \blum{\Psi})$ is a morphism from $\sem{\blum{\Omega}, \blum{a : q}, \blum{\Psi}}$ to $\sem{\blum{\Omega},\blum{\Psi}}$ projecting the $\blum{q}$ part. \\

Now let $\blum{\Omega},\blum{\Psi},\blum{p},\blum{q}$ be as before and $\blum{i}$ a pre-index. We define

\begin{center}
\begin{tabular}{l}
$\mbf{T}(\blum{\Omega};\blum{q};\blum{\blum{\diamond}};\blu{i}) \defeq \overline{\sem{\blum{\Omega;i}}}$\\
$\mbf{T}(\blum{\Omega};\blum{q};\blum{\Psi},\blu{a \! : \! r};\blum{i}) \defeq \frak q (\mbf{T}(\blum{\Omega};\blum{q};\blum{\Psi};\blum{i}), \sem{\blum{\Omega},\blum{b : q}, \blum{\Psi}; \blu{r}}) \hspace{3.5ex} \blum{b} \text{ fresh}$
\end{tabular}
\end{center}

The idea here is that $\mbf{T}(\blum{\Omega} ; \blum{q} ; \blum{\Psi} ; \blum{i})$ is a morphism from $\sem{\blum{\Omega},\blum{\Psi}[\blum{i}/\blum{b}]}$ to $\sem{\blum{\Omega}, \blum{b} : \blum{q}, \blum{\Psi}}$ yielding $\sem{\blum{\Omega} ; \blum{i}}$ at the $\blum{b \! : \! \blum{q}}$ position and variables otherwise.\\~\\
The above ideas must be proven simultaneously in the form of weakening and substitution lemmas.

\begin{lemma}
(Weakening) Let $\blum{\Omega},\blum{\Psi}$ be pre-contexts, $\blum{p},\blum{q}$ pre-sorts, $\blum{i}$ a pre-index, and $\blum{b}$ a fresh variable. Let $\blum{A} \in \{ \blum{p}, \blum{i} \}$. The expression $\mbf{P}(\blum{\Omega} ; \blum{p} ; \blum{\Psi})$ is defined iff $\sem{\blum{\Omega}, \blum{p \! : \! q}, \blum{\Psi}}$ and $\sem{\blum{\Omega}, \blum{\Psi}}$ are defined and in this case is a morphism from the former to the latter. If $\sem{\blum{\Omega},\blum{\Psi} ; \blum{A}}$ is defined then 
$$\sem{\blum{\Omega}, \blum{b \! : \! p}, \blum{\Psi} ; \blum{A}} \simeq \sem{\blum{\Omega} , \blum{\Psi} ; \blum{A}} \{ \mbf{P}(\blum{\Omega}; \blum{p} ; \blum{\Psi}) \}$$
\end{lemma}

\begin{lemma}
\label{lemma:indsortsub}
(Substitution) Let $\blum{\Omega},\blum{\Psi}$ be pre-contexts, $\blum{p},\blum{q}$ pre-sorts, $\blum{i}, \blum{j}$ pre-indices, and $\blum{b}$ a fresh variable. Let $\blum{A} \in \{ \blum{p}, \blum{i} \}$ and suppose that $\sem{\blum{\Omega} ; \blum{i}}$ is defined. 

The expression $\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{i})$ is defined iff $\sem{\blum{\Omega}, \blum{\Psi}[\blum{i}/\blum{b}]}$ and $\sem{\blum{\Omega} , \blum{b \! : \! p}, \blum{\Psi}}$ are both defined and in this case is a morphism from the former to the latter. If $\sem{\blum{\Omega},\blum{b \! : \! p},\blum{\Psi} ; \blum{A}}$ is defined then 
$$\sem{\blum{\Omega},\blum{\Psi}[\blum{i}/\blum{b}]; \blum{A}[\blum{i}/\blum{b}]} \simeq \sem{\blum{\Omega},\blum{b} \! : \! \blum{p},\blum{\Psi};\blum{A}} \{ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi} ; \blum{i}) \}$$
\end{lemma}

\begin{proof}
TODO
\end{proof}

\begin{lemma}
\label{lemma:indsortsub-syntax}
If $\blum{\Omega, a:p,\Psi \vdash q}$ and $\blum{\Omega \vdash j : p}$ then $\blum{\Omega, \Psi[j/a] \vdash q[j/a]}$.
\end{lemma}

\begin{proof}
TODO
\end{proof}

Now that the above standard lemmas have been established, we state and prove our substitution lemmas.

\begin{lemma}
If $\blum{\Omega,a : p, \Psi} \vdash \kappa$ and $\blum{\Omega \vdash j : p}$ then $\blum{\Omega, \Psi[j/a]} \vdash \kappa[\blum{j}/\blum{a}]$
and $$\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \sem{\blum{\Omega,a:p,\Psi} \vdash \kappa} \cong \sem{\blum{\Omega, \Psi[j/a]} \vdash \kappa[\blum{j}/\blum{a}]}$$
\end{lemma}

\begin{proof}
By induction on the proof of $\blum{\Omega,a : p, \Psi} \vdash \kappa$.\\
\begin{description}
\item[Case \begin{sc}WFK-IndAbs\end{sc}:]~\\
We have $\kappa = \forall \blum{q}. \kappa'$. Our premises are $\blum{\Omega,a : p, \Psi \vdash q}$ and $\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \kappa'$.
Applying lemma \ref{lemma:indsortsub-syntax} we have $\blum{\Omega, \Psi[j/a] \vdash q[j/a]}$ and hence $\sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} \downarrow$.
By lemma \ref{lemma:indsortsub} we have $$\sem{\blum{\Omega,a:p,\Psi \vdash q}} \{ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi} ; \blu{j}) \} = \sem{\blum{\Omega,\Psi[\blum{j}/\blum{a}] \vdash q[\blum{j}/\blum{a}]}}$$
Applying the IH to the second premise we have
$$\blum{\Omega,\Psi[j/a],b : q[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \kappa'[\blum{j}/\blum{a}]$$
and
$$ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi}, \blum{b : q} ; \blu{j})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \kappa'} \cong \sem{\blum{\Omega, \Psi[\blum{j}/a], b : q[\blum{j}/\blum{a}]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \kappa'[\blum{j}/\blum{a}]} $$
Applying \begin{sc}WFK-IndAbs\end{sc} we get
\begin{mathpar}
\inferrule
  {\blum{\Omega,\Psi[j/a] \vdash q[j/a]} \\ \blum{\Omega,\Psi[j/a],b : q[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \kappa'[\blum{j}/\blum{a}]}
  {\blum{\Omega,\Psi[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}
\end{mathpar}

Additionally, we have\\~\\
\begin{align*}
 &\quad \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \sem{\blum{\Omega,a:p,\Psi} \vdash \forall \blum{q}. \kappa'}\\
=&\qquad \text{\{ Interpretation of \begin{sc}KF-Forall\end{sc} \}} \\
 &\quad \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \Pi_{\sem{\blum{\Omega, a : p, \Psi \vdash q}}} \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}\\
\cong&\qquad \text{\{ Beck-Chevalley For Dependent Simple Products, taking } \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) \text{ as } u \}\\
 &\quad \Pi_{ \sem{\blum{\Omega, a : p, \Psi \vdash q}} \{ \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) \} } \frak q(\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) , \sem{\blum{\Omega, a:p, \Psi \vdash q}})^* \sem{\blum{\Omega,a:p,\Psi,b : q} \vdash \kappa'}\\
=&\qquad \text{ \{ Lemma \ref{lemma:indsortsub} \}}\\
 &\quad \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \frak q(\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) , \sem{\blum{\Omega, a:p, \Psi \vdash q}})^* \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}\\
=&\qquad \text{\{ Definition of } \mbf{T} \}\\
 &\quad \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \mbf T(\blum{\Omega}; \blum{p} ; \blum{(\Psi, a : q)}; \blum{j})^* \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}\\
=&\qquad \text{\{ IH \}} \\ 
 &\quad \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \sem{\blum{\Omega,\Psi[j/a],b:q[j/a]} \vdash \kappa'[\blum{j}/\blum{a}]}\\
=&\qquad \text{\{ Interpretation of \begin{sc}KF-Forall\end{sc} \}}\\
 &\quad \sem{\blum{\Omega,\Psi[j/a]} \vdash \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}\\
=&\qquad \text{\{ Definition of Index-to-Type Substitution \}}\\
 &\quad \sem{\blum{\Omega,\Psi[j/a]} \vdash (\forall \blum{q}. \kappa')[\blum{j}/\blum{a}]}
\end{align*}

%\begin{align*}
% &\quad \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \sem{\blum{\Omega,a:p,\Psi} \vdash \forall \blum{q}. \kappa'}\\
%\end{align*}

\iffalse
Additionally, we have\\~\\
$\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \sem{\blum{\Omega,a:p,\Psi} \vdash \forall \blum{q}. \kappa'}$\\
$= \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \Pi_{\sem{\blum{\Omega, a : p, \Psi \vdash q}}} \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}$\\
$\cong \Pi_{ \sem{\blum{\Omega, a : p, \Psi \vdash q}} \{ \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) \} } \frak q(\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) , \sem{\blum{\Omega, a:p, \Psi \vdash q}})^* \sem{\blum{\Omega,a:p,\Psi,b : q} \vdash \kappa'}$\\
$= \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \frak q(\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) , \sem{\blum{\Omega, a:p, \Psi \vdash q}})^* \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}$\\
$= \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \mbf T(\blum{\Omega}; \blum{p} ; \blum{(\Psi, a : q)}; \blum{j})^* \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}$\\
$= \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \sem{\blum{\Omega,\Psi[j/a],b:q[j/a]} \vdash \kappa'[\blum{j}/\blum{a}]}$\\
$= \sem{\blum{\Omega,\Psi[j/a]} \vdash \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}$\\
$= \sem{\blum{\Omega,\Psi[j/a]} \vdash (\forall \blum{q}. \kappa')[\blum{j}/\blum{a}]}$\\
\fi


\item[Other cases:]~\\
TODO
\end{description}

\end{proof}

\begin{lemma}
If $\blum{\Omega,a : p, \Psi} \mid \Gamma \vdash \tau : \kappa$ and $\blum{\Omega \vdash j : p}$ then $\blum{\Omega, \Psi[j/a]} \mid \Gamma[\blum{j}/\blum{p}] \vdash \tau[\blum{j}/\blum{p}] : \kappa[\blum{j}/\blum{p}]$ and
$$\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \sem{\blum{\Omega, a:p, \Psi} \mid \Gamma \vdash \tau : \kappa} \cong \sem{\blum{\Omega, \Psi[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau[\blum{j}/\blum{a}] : \kappa[\blum{j}/\blum{a}]}$$
\end{lemma}

\begin{proof}
By induction on the proof of $\blum{\Omega, a : p, \Psi} \mid \Gamma \vdash \tau : \kappa$.
\begin{description}
\item [Case \sc{K-IndAbs}:]~\\
We have $\tau = \lambda \blum{b : q}. \tau'$ and $\kappa = \forall \blum{q}. \kappa'$. Our premises are $\blum{\Omega, a:p, \Psi \vdash q}$ and $\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'$.
Applying lemma \ref{lemma:indsortsub-syntax} we have $\blum{\Omega, \Psi[j/a] \vdash q[j/a]}$ and hence $\sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} \downarrow$.
By lemma \ref{lemma:indsortsub} we have $$\sem{\blum{\Omega,a:p,\Psi \vdash q}} \{ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi} ; \blu{j}) \} = \sem{\blum{\Omega,\Psi[\blum{j}/\blum{a}] \vdash q[\blum{j}/\blum{a}]}}$$
Applying the IH to the second premise we have $$\blum{\Omega, \Psi[\blum{j}/\blum{a}], b : q[\blum{j}/\blum{a}]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau'[\blum{j}/\blum{a}] : \kappa'[\blum{j}/\blum{a}]$$
and
$$ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi}, \blum{b : q} ; \blu{j})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'} \cong \sem{\blum{\Omega, \Psi[\blum{j}/a], b : q[\blum{j}/\blum{a}]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau'[\blum{j}/\blum{a}] : \kappa'[\blum{j}/\blum{a}]} $$
Now, applying the \begin{sc}K-IndAbs\end{sc} rule, we get
\begin{mathpar}
\inferrule
  {\blum{\Omega,\Psi[j/a] \vdash q[j/a]} \\ \blum{\Omega,\Psi[j/a],b : q[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau'[\blum{j}/\blum{a}] : \kappa'[\blum{j}/\blum{a}]}
  {\blum{\Omega,\Psi[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \lambda \blum{b : q[j/a]}. \tau'[\blum{j}/\blum{a}] : \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}
\end{mathpar} 

We prove ?? by cases on $\Psi$:

\begin{description}

\item[Case $\blum{\Psi} = \blum{\diamond}$:]~\\
TODO.

\item[Case $\blum{\Psi} = \blum{(\Psi', c : r)}$~:]~\\
Let $\alpha : \frak p(\sem{\blum{\Omega,a:p,\Psi ; q}} \{ \mbf{T}(\blum{\Omega}; \blum{p}; \blum{\Psi}; \blum{j} ) \})^* \mbf{T}(\blum{\Omega}; \blum{p}; \blum{\Psi}; \blum{j} )^* \to \frak q(\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{j})^*, \sem{\blum{\Omega,a:p,\Psi ; q}})^* \frak p(\sem{\blum{\Omega,a:p,\Psi ; q}})^*$\\
i.e. $\alpha : \frak p(\sem{\blum{\Omega,\Psi[j/a] ; q[j/a]}})^* \mbf{T}(\blum{\Omega}; \blum{p}; \blum{\Psi}; \blum{j} )^* \to \frak q(\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{j})^*, \sem{\blum{\Omega,a:p,\Psi ; q}})^* \frak p(\sem{\blum{\Omega,a:p,\Psi ; q}})^*$\\~\\
%Let $\alpha : \frak p(\blum{\Omega,\Psi[j/a] \vdash q})^* \frak q(\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{j}), \sem{\blum{\Omega,a:p,\Psi ; q}})^* \to  ?   $\\
$\sem{\blum{\Omega, \Psi'[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \lambda \blum{b : q[j/a]}. \tau'[\blum{j}/\blum{a}] : \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}$\\
$= \sem{\blum{\Omega,\Psi'[j/a], b : q[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau'[\blum{j}/\blum{a}] : \kappa'[\blum{j} / \blum{a}] }^\sharp$\\
$\cong (\mbf{T}(\blum{\Omega}; \blum{p} ; \blum{(\Psi, b:q)} ; \blum{j})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'})^\sharp$\\
$= (\frak q(\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{j}), \sem{\blum{\Omega,a:p,\Psi ; q}})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'})^\sharp$\\
$\cong (\frak q(\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{j}), \sem{\blum{\Omega,a:p,\Psi ; q}})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'} \circ \frak p^*(\alpha_{\sem{\blum{\Omega, a:p, b:q} \vdash \Gamma}}) )^\sharp$\\

$\cong (\Pi_{\sem{\blum{q}}}(\alpha) ; )$\\~\\

$\mbf{T}(\blum{\Omega} ; \blum{p} ; (\blum{\Psi}, \blum{c : r}) ; \blum{j})^*\sem{\blum{\Omega, a : p, \Psi} \mid \Gamma \vdash \lambda \blum{b : q}. \tau' : \forall \blum{q}. \kappa'}$\\
$= \frak q(\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{j}), \sem{\blum{\Omega,a:p,\Psi ; r}})^* \sem{\blum{\Omega, a : p, \Psi} \mid \Gamma \vdash \lambda \blum{b : q}. \tau' : \forall \blum{q}. \kappa'}$\\
$= \frak q(\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{j}), \sem{\blum{\Omega,a:p,\Psi ; r}})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'}^\sharp$\\
%todo\\
%$= $


\end{description}

We also have\\~\\
$\mbf{T}(\blum{\Omega} ; \blum{p} ; (\blum{\Psi}, \blum{b : q}) ; \blum{j})^*\sem{\blum{\Omega, a : p, \Psi} \mid \Gamma \vdash \lambda \blum{b : q}. \tau' : \forall \blum{q}. \kappa'}$\\
$= \frak q(\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{j}), \sem{\blum{\Omega,a:p,\Psi ; q}})^* \sem{\blum{\Omega, a : p, \Psi} \mid \Gamma \vdash \lambda \blum{b : q}. \tau' : \forall \blum{q}. \kappa'}$\\


\end{description}
\end{proof}

%\begin{figure}
%\beg[[
%\begin{tabular}{l
%(``Alonzo Church'', ``Purchases'', ``0'', ``itemId'') $\mapsto$ ``Sony Digital Paper'' \\
%(``Alonzo Church'', ``Purchases'', ``0'', ``cardId'') $\mapsto$ ``Alonzo's Card''\\
%(``Alonzo Church'', ``Cards'', ``Alonzo's Card'', ``Addr'') $\mapsto$ ``12 Main St''\\
%(``Alonzo Church'', ``Cards'', ``Alonzo's Card'', ``Type'') $\mapsto$ ``Visa''\\~\\

%(``Alan Turing'', ``Cards'', ``Alan's Card'', ``Addr'') $\mapsto$ ``312 Some Rd''\\
%(``Alan Turing'', ``Cards'', ``Alan's Card'', ``Type'') $\mapsto$ ``Mastercard''\\
%\end{tabular}

%\end{small}

%\end{figure}

%Hierarchical database schemas are often informally documented in wikis. These informal schemas can easily omit important details, 

%We use a simplified model of hierachical databases. A \emph{location} is a list of strings, and a \emph{database instance} is a partial function from lists of strings to strings. Initially, it is totally undefined, and each store defines the database at a specific  

%To demonstrate the benefits and pitfalls of hierarchical database schemas



\end{document}
