\documentclass[sigplan,10pt,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=true}
\bibliographystyle{ACM-Reference-Format}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{tikz}
\usepackage{quiver}
\usepackage{bussproofs}
\usepackage{amsmath}

\usetikzlibrary{cd}

\lstset{
  basicstyle=\small\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  numbers=left
}

\newcommand{\blu}[1]{\textbf{\color{blue}{#1}}}
\newcommand{\blum}[1]{\mathbf{\color{blue}{#1}}}
\newcommand{\defeq}{\overset{\mathit{def}}{=}}
\newcommand{\defequiv}{\overset{\mathit{def}}{\Leftrightarrow}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\fm}[2]{
\left(
\tiny
#1
\normalsize
\right)_{#2}
}

\title{Indexed Kind Checking for Hierarchical Database Schemas}
\author{Kevin Clancy}

 
\begin{document}

%\category{D.3.3}{Test 1}
%\terms{Languages}
\keywords{Indexed types, Database schemas, Dependent types}
\ccsdesc[100]{.}


\begin{abstract}

Types are an appropriate tool for describing the structure of hierarchical databases. But two common database idioms, \emph{foreign keys} and \emph{secondary indices}, cannot be expressed using standard type systems. We present a lanaguage in which a database schema is described using a type layered over a dependently sorted index language. The index language consists of keys and relations on keys. Multiple occurrences of the same index-level relation inside of a schema establish a correlation between two distinct portions of a database instance; both secondary indices and foreign keys can be specified in this manner. We present an algorithmic system of judgments for deciding an indexed kinding relation on this schema language, and provide it with an intrinsic denotational semantics.  

%We present a lanaguage in which a database schema is described using a type layered over a dependently sorted index language of keys and relations on keys. A dictionary type constructor binds a sequence of $n$ index variables corresponding to a sequence of $n$ nested keys. It also includes a proposition, typically an application of an $n$-ary predicate on keys, which determines the exact set of key sequences that a database instance must contain. We a reconfiguration by including the same predicate in multiple dictionary types.


\end{abstract}

\maketitle

\section{Introduction}

Programmers increasingly choose document database systems, such as DynamoDB, due to their high performance and intuitive hierarchical structure. Schemas for such databases are often intentionally omitted under the premise that they inhibit rapid iteration. However, we disagree with this premise. We believe that the arguments in favor of database schemas are analogous to those in favor of static types in programming langauges. By pairing data with its indended meaning, a schema increases programmer comprehension: a programmer may not know what do with a record field called \emph{widgetId}, but a good schema could convey this information, specifying that a widgetId refers to a structure stored in a specific location of the database.

The type syntax of a standard programming lanaguage such as Typescript is, for the most part, an appropriate tool to describe the structure of modern hierarchical databases. However, two common features of hierarchical databases lie beyond the reach of standard type systems. First, a database may store \emph{foreign keys}: values, such as the aforementioned \emph{widgetId}, used to refer to entities stored elsewhere in the database. Second, a database may replicate a dataset in multiple configurations (a.k.a. \emph{secondary indices}) to accomodate multiple access patterns in an efficient, spatially local manner. 

The prevalence of foreign keys in hierarchical databases constrasts sharply against the in-memory data structures one typically finds in general purpose lanaguages. A pointer in a language such as C++ is not a foreign key, because statically our concern is the type of referenced data rather than its location. In contrast, a foreign key is drawn from a specific subset of references of a given type. For example, consider an e-commerce database which records purchases performed by customers. Each purchase holds a \emph{creditCardId} foreign key referring to the credit card used for the payment; this card is not drawn from a global pool of all cards, but instead the pool of cards owned by the customer which made the purchase. 

Secondary indices are also common and useful database structure beyond the reach of traditional type systems. Consider this example demonstrating the utility of secondary indices. An e-commerce company wishes to issue a recall on a product. To do so, it must obtain a list of all customers that have purchased an item known to be defective; to compute this list efficiently, the set of all customers which purchased each item must be stored in nearby addresses. At another time, a customer may wish to obtain a list of all items he has purchased from the site; to perform this operation efficiently, we must store the set of all of a customer's purchased items in nearby addresses. These two requirements are at odds if our database merely stores a single collection of all purchases processed. However, if we redundantly store customer-to-item and item-to-customers map, we can satisfy both requirements at once. Such redundant data structures are called secondary indices.

In practice, foreign keys often refer to deleted entities. Such a foreign key is a time-bomb which will raise an exception the next time the data is accessed. Secondary indices can become out-of-sync due to programmer errors. A formal schema language including notions of foreign keys and indices could be compiled to validation routines to detect these errors.

We make the following contributions.
\begin{itemize}   
\item We design an expressive schema language for hierarchical databases featuring foreign keys and secondary indices. 
\item We provide a category-theoretic characterization of the dependently-sorted equivalent of simple products, which plays a central role in our schema language. This characterization is similar to, but more general than, exisiting characterizations e.g. by Palmgren \cite{palmgren2019categories}; in particular, we identify a \emph{transpose distribution} property necessary for dependent simple products in models whose total categories, unlike Palmgren's, are not thin.

\end{itemize}

Since we are working with two distinct concepts which are both typically referred to as \emph{indices} -- indices in the sense of database indices and indices in the sense of indexed type checking -- we refer to database secondary indices as \emph{reconfigurations} in the sequel.

%Likewise, we don't have 
%Chronicles indexing on pg 9040.


%\pagebreak


\section{Example}


%The schema begins with some predicate declarations. On the first line, 
%``\verb!(ItemId : str -> prop) =>!'' binds a predicate scoped over the rest of the schema fragment. 
%This forms an index-to-type abstraction mapping each unary predicate on strings to a schema.  

%NewMiscStudy pg 9047 describes chronicles indices.

\subsection{Foreign Keys}

\begin{figure}

\begin{lstlisting}[escapeinside=`']
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{ItemId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CustId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{PurchaseId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CardType : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CardId : (x:str) -> prf (CustId x) -> str -> prop}').

type Card = {
  billingAddr : str
  cardType    : { `\blu{x : str}' | `\blu{CardType x}' }
}

type Purchase = `$\lambda$(\blu{cust : str}).$\lambda$(\blu{prf (CustId cust)}).' {
  itemId : { `\blu{x : str}' | `\blu{ItemId x}' }, 
  cardId : { `\blu{x : str}' | `\blu{CardId cust x}' }
}

type Customer = `$\lambda$(\blu{cust : str}).$\lambda$(\blu{prf (CustId cust)}).' { 
  purchases : { 
    [`\blu{p : str}'] : `\blu{PurchaseId p}' > Purchase `\blu{cust}' 
  },
  cards     : { 
    [`\blu{card : str}'] : `\blu{CardId cust card}' > Card 
  }
}

{
  cardTypes : { [`\blu{x : str}'] : `\blu{CardType x}' > "*" }
  customers : { [`\blu{x : str}'] : `\blu{CustId x}' > Customer `\blu{x}'}
}
\end{lstlisting}

\caption{Schema for e-commerce database with foreign keys}
\label{fig:ecommerce}
\end{figure}

The purpose of a schema is to identify a set of database instances, so before examining our first schema we briefly define some formalisms for describing database instances. We consider \emph{database instances} (also called \emph{instances}) as partial mappings from lists of strings to strings. Given a database instance $f$ and a list of strings $\sigma$, we obtain an instance $f |_\sigma$ called \emph{the restriction of $f$ to $\sigma$}, defined for lists $\sigma'$ as $f |_\sigma(\sigma') \defeq f(\sigma + \! \! +~\sigma')$, where $\sigma + \! \! +~ \sigma'$ is the concatenation of $\sigma$ and $\sigma'$. By an abuse of language, we say ``$f$ maps $\sigma$ to $f |_{\sigma}$''. We write $[s_1, \ldots, s_n]$ for the list containing the $n$ strings $s_1,\ldots,s_n$. 

Figure \ref{fig:ecommerce} shows a schema fragment for an e-commerce database. It begins by declaring five predicates: first four unary predicates for item ids, customer ids, purchase ids, and card types, and then a ternary predicate for card ids. The predicate variables and their classifiers have been bolded and colored blue to indicate that they are part of the \emph{index language}. This simple language defines conceptual entities such as predicates and relations, divorced from the physical details of where these entities are stored. The index langauge is layered beneath our schema language, i.e. schemas may depend on indices but not vice versa. 

Lines 7-10 use the record type constructor to define a subschema representing credit cards. It denotes the set of instances which map the list [``billingAddr''] to any string and the list [``cardType''] to any string satisfying the \lstinline[mathescape]{$\blu{CardType}$} predicate. We consider the latter a foreign key; rather than taking the naive view that a foreign key is a reference to a specific location in the database, we instead take it to be a string satisfying a predicate in our index-level context (i.e. an element of a conceptual set). We believe our approach is cleaner and more declarative than the naive approach. Because a conceptual set may be replicated at multiple locations in a database, it would not make sense for a foreign key to refer to one of these locations rather than another.

%The field \emph{cardId} is an instance of a foreign key. In this schema language, foreign keys don't refer directly to locations in the database; instead, they refer to index-level unary predicates. By separating conceptual sets (index-level predicates) from their physical  

Lines 12-15 define an index-to-type operator called \emph{Purchase}, which maps a string \lstinline[mathescape]{$\blu{cust}$} and a proof that \lstinline[mathescape]{$\blu{cust}$} satisfies the \lstinline[mathescape]{$\blu{CustId}$} predicate to a type representing purchases made by customer \lstinline[mathescape]{$\blu{cust}$}. In the application \lstinline[mathescape]{$\blu{CardId cust card}$}, the second argument to  \lstinline[mathescape]{$\blu{CardId}$} is missing. This is because it is a proof; since any two proofs of the same proposition are interchangeable, we apply proofs implicitly to reduce visual clutter. 

Lines 17-24 define a index-to-type operator \lstinline{Customer} mapping a string \lstinline[mathescape]{$\blu{cust}$} and a proof of \lstinline[mathescape]{$\blu{CustId cust}$} to a type representing customers with id \lstinline[mathescape]{$\blu{cust}$}. It denotes the set of instances which
\begin{itemize}
\item Map all lists [``purchases'', \lstinline[mathescape]{$\blu{p}$}] such that \lstinline[mathescape]{$\blu{purchaseId p}$} holds to instances of type \lstinline[mathescape]{Purchase $\blu{cust}$}, and 
\item Map all lists [``cards'', \lstinline[mathescape]{$\blu{card}$}] such that \lstinline[mathescape]{$\blu{CardId cust card}$} holds to instances of type \lstinline{Card}.
\end{itemize}

Finally, lines 26-29 define the schema using a record type. It denotes the set of instances which 
\begin{itemize}
\item Map [``cardTypes''] to a subinstance that stores the set of all card types by mapping each string \lstinline[mathescape]{$\blu{x}$} satisfying the \lstinline[mathescape]{$\blu{CardType}$} predicate to the string \lstinline[mathescape]{"*"}, and
\item Map [``customers''] to a dictionary that maps every \lstinline[mathescape]{$\blu{x}$} satisfying the \lstinline[mathescape]{$\blu{CustId}$} predicate to a subschema of type \lstinline[mathescape]{Customer $\blu{x}$}. 
\end{itemize}

%The code \lstinline[mathescape]{$\lambda (\blu{ItemId : str -> prop})/$} on the first line is an abstraction mapping indices of sort \lstinline[mathescape]{$\blu{str -> prop}$} to the type whose syntax occupies the remaining lines of the figure. A type denotes a set of database instances.

\subsection*{Reconfigurations}


\begin{figure} 

\begin{small}
\begin{lstlisting}[escapeinside=`']
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{ItemId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{CustId : str -> prop}').
`$\bigvee \!\!$' `$\lambda \!\!$' (`\blu{Purchased : \\ \hspace{1cm} (x : str) -> prf (CustId x) -> \\ \hspace{1cm} (y : str) -> prf (ItemId y) -> prop}').

{ 
  custToItem : { 
    [`\blu{c,i : str}'] : `\blu{CustId c}, 
                           \blu{ItemId i}, 
                           \blu{Purchased c i}' > "*" 
  }
  itemToCust : { 
    [`\blu{i,c : str}'] : `\blu{CustId c}, 
                           \blu{ItemId i}, 
                           \blu{Purchased c i}' > "*"
  }
}
\end{lstlisting}

\end{small}
\caption{Reconfigurations (secondary indices) in an e-commerce database}
\label{fig:ecommerce-indices}
\Description[Secondary indices]{Secondary indices in an e-commerce database}
\end{figure}

Figure \ref{fig:ecommerce-indices} shows a schema for a simple database with reconfigurations. An instance satisfies the schema if 
\begin{itemize}
\item For each customer/item pair \lstinline[mathescape]{$\blu{c}$}, \lstinline[mathescape]{$\blu{i}$} satisfying \lstinline[mathescape]{$\blu{Purchased c i}$}, it maps \lstinline[mathescape]{["custToItem", $\blu{c}$, $\blu{i}$]} to the string \lstinline[mathescape]{"*"} and \lstinline[mathescape]{["itemToCust", $\blu{i}$, $\blu{c}$]} to \lstinline[mathescape]{"*"}.
\item It is not defined anywhere else.
\end{itemize}

Such an instance allows us to efficiently query both the set of all items purchased by a customer (via \lstinline[mathescape]{custToItem}) and the set of all customers which purchased an item (via \lstinline[mathescape]{itemToCust}). Importantly, the two fields both refer to the same set of purchase entities via the index-level relation \lstinline[mathescape]{$\blu{Purchased}$}.

\section{Syntax}

\iffalse

\begin{tabular}{llll}
$\mathit{Chars}$ & $\doteq$ & the set of all characters \\
$\mathit{TypeVars}$ & $\doteq$ & the set of all type variables \\
$\mathit{IndexVars}$ & $\doteq$ & the set of all index variables \\
$x,y,z$ & $\in$ & $\mathit{TypeVars}$ & ~ \\
$\blu{a}, \blu{b}, \blu{P}$ & $\in$ & $\mathit{IndexVars}$ & ~ \\
$\blu{c}$ & $\in$ & $\mathit{Chars}$ & (characters) \\
$\blu{s},\blu{t}$ & $\in$ & $\mathit{Strings}$ & (where $\mathit{Strings} = \mathit{Chars}^{\star}$) \\~\\
 & & \\
$\blu{j},\blu{k}$ (index) & ::=  & $\blu{s}$ & (string literal) \\
                          & $\mid$ & $\blu{App_{[a : q],p}(j,k)}$ & (index application) \\
                          & $\mid$ & $\blu{a}$ & (index variable) \\~\\
$\blu{C}$ (string classifiers) & ::= & $\blu{s}$ & (string singleton) \\
                         & $\mid$ & $\blu{str}$ & (all strings) \\~\\
$\blu{q},\blu{r}$ (sort) & ::= & $\blu{C}$ & (sort of strings satisfying $C$) \\
                         & $\mid$ & $\blu{\textbf{prop}}$ & (proposition sort) \\
                         & $\mid$ & $\blu{\textbf{prf}~\phi}$ & (proof sort) \\
                         & $\mid$ & $\blu{(a : q) \Rightarrow r}$ & (dependent function sort) \\~\\
$\kappa,\rho$ (kind) & $::=$ & $\ast$ & (kind of proper types) \\
                     & $\mid$ & $\kappa \to \rho$ & (type-to-type operator)\\
                     & $\mid$ & $\forall \blu{q}.~\kappa$ & (index-to-type operator) \\~\\
$\tau,\sigma$ (type) & $::=$ & $\{[\blu{a : C}] : \tau \}$ & (dictionary type) \\ 
       & $\mid$ & $\{ \blu{s}_i : \tau_i^{~i \in 1..n} \}$ & (record type) \\
       & $\mid$ & $\langle \blu{C} \rangle$ & (string type) \\
       & $\mid$ & $\lambda \blu{a : q} . \tau$ & (index-to-type abstraction) \\
       & $\mid$ & $\lambda x : \kappa. \tau$ & (type-to-type abstraction) \\
       & $\mid$ & $\bigvee \tau$ & (colimit) \\
       & $\mid$ & $\tau~\sigma$ & (type application) \\
       & $\mid$ & $\tau~[~\blu{j}~]$ & (index-to-type application)
\end{tabular}

\fi 

\begin{figure}
\begin{tabular}{llll}
$\mathit{TypeVars}$ & $\defeq$ & the set of all type variables \\
$\mathit{IndexVars}$ & $\defeq$ & the set of all index variables \\
$x,y,z$ & $\in$ & $\mathit{TypeVars}$ & ~ \\
$\blu{a}, \blu{b}, \blu{P}$ & $\in$ & $\mathit{IndexVars}$ & ~ \\
$\blu{s},\blu{t}$ & $\in$ & $\mathit{Strings}$ & ~ \\
\end{tabular}\\~\\~\\
\begin{tabular}{llll}
$\blu{i},\blu{j},\blu{k}$ (index) & ::=  & $\blum{s}$ & (string literal) \\
                          & $\mid$ & $\blum{App}_{\blum{[a : q],p}}\blum{(j,k)}$ & (index application) \\
                          & $\mid$ & $\blu{a}$ & (index variable) \\
                          & $\mid$ & $\blu{true}$ & (true proposition) \\
~ & ~ & ~ & ~ \\
$\blu{p},\blu{q},\blu{r}$ (sort) & ::= & $\blum{str}$ & (string sort) \\
                         & $\mid$ & $\blum{prop}$ & (proposition sort) \\
                         & $\mid$ & $\blum{prf~j}$ & (proof sort) \\
                         & $\mid$ & $\blum{(a : q) \to r}$ & (function sort) \\
~ & ~ & ~ & ~ \\
$\tau,\sigma$ (pre-type) & $::=$ & $\{[\blu{a : str}] : \tau \}$ & (dictionary) \\ 
       & $\mid$ & $\{ \blu{s}_i : \tau_i^{~i \in 1..n} \}$ & (record) \\
       & $\mid$ & $\{ \blu{a : str} \mid \blu{i} \}$ & (string refinement) \\
       & $\mid$ & $\lambda \blu{a : q} . \tau$ & (index-to-type abstr.) \\
       & $\mid$ & $\lambda x : \kappa. \tau$ & (type-to-type abstr.) \\
       & $\mid$ & $\bigvee \tau$ & (union) \\
       & $\mid$ & $\tau~\sigma$ & (type app.) \\
       & $\mid$ & $\tau~[~\blu{j}~]$ & (index-to-type app.)\\
~ & ~ & ~ & ~ \\
$\kappa,\rho$ (pre-kind) & $::=$ & $\ast$ & (proper type pre-kind) \\
                     & $\mid$ & $\kappa \to \rho$ & (type-to-type op)\\
                     & $\mid$ & $\forall \blu{q}.~\kappa$ & (index-to-type op)
\end{tabular}\\~\\~\\
\begin{tabular}{llll}
$\blum{\Omega}, \blum{\Psi}$ (pre-sort-context) & $::=$  & $\blum{\Omega,a : q}$ & (extension) \\
                                     & $\mid$ & $\blum{\diamond}$ & (empty) \\~\\
$\Gamma$ (pre-kind-context) & $::=$ & $\Gamma,x : \kappa$ & (extension) \\
                        & $\mid$ & $\diamond$ & (empty) 
\end{tabular}
\caption{Syntax}
\label{fig:syntax}
\Description[Syntax]{Syntax}
\end{figure}

Index-level terms $\blum{i,j,k}$ consist of string literals, variables, applications, and the proposition constant $\blum{true}$. An application is annotated with the domain and codomain of the applied function; this eases the definition of our denotational semantics, but the types can be inferred and are thus omitted in our examples, which instead use the notation $\blum{j}~\blum{k}$ as shorthand for $\blum{App_{[a : q], p}(j,k)}$.

Following \cite{xi2007dependent}, index level classifiers are called \emph{sorts}. Sorts are written using the variables $\blum{p,q,r}$. We include the sorts $\blum{str}$ for strings, $\blum{prop}$ for propositions, $\blum{prf}~j$ proofs of the proposition $\blum{j}$, and the sort constructor $\blum{(a : q) \to r}$ for constructing dependen function sorts, which are essentially index-level $\Pi$-types.

Our types $\tau,\sigma$ are also called \emph{schemas}. The type $\{ [\blum{a : str}] : \tau \}$ represents string-keyed dictionaries of value type $\tau$. The type $\tau$ depends on the index variable $\blum{a}$, and $\{ [\blum{a : str}] : \tau \}$ describes the set of database instances which contains exactly those root-level keys $\blum{s}$ such that $\tau[\blum{s/a}]$ represents a non-empty set of database instances. Record types, type-type applications, and type-type abstractions in our type syntax are standard. A string refinement type of the form $\{ \blum{a : str} \mid \blum{i} \}$ represents the set of all strings $\blum{s}$ such that $\blum{i[s/a]}$ holds.

Finally, our type syntax include index-type abstractions $\lambda (\blum{a : q}). \tau$, index-type application $\tau~[~\blum{j}~]$, and union $\bigvee \tau$. In a well-kinded union type $\bigvee \tau$, the type $\tau$ is an index-type function whose codomain is $\ast$ (the kind of proper types). $\tau$ then denotes a function which maps a semantic index to a set of database instances; $\bigvee \tau$ denotes the union over the applications of $\tau$ to all semantic indices in its domain. 
   
In figures \ref{fig:ecommerce} and \ref{fig:ecommerce-indices}, a dictionary type of the form $\{ [\blum{a :str}] : \blum{i_1, \ldots, i_n} > \tau \}$ is sugar for $$\{ [\blum{a :str}] : \bigvee \lambda \blum{(a_1 : prf~i_1}) \ldots \bigvee \lambda (\blum{a_n : prf~i_n}). \tau \}$$

\section{Static semantics}

\subsection{Index-level static semantics}

\begin{figure}
\begin{mathpar}
\inferrule
  {~}
  {\blum{\Omega \vdash s : str}}
\and
\inferrule
  {~}
  {\blum{\Omega,a : q, \Omega' \vdash a : q}}
\and
\inferrule
  {\blum{\Omega \vdash j : (a : q) \to r} \\ \blum{\Omega \vdash k : q}}
  {\blum{\Omega \vdash App_{[a : q],r}(j,k) : r[k/a]}}
\and
\inferrule
  {~}
  {\blum{\Omega \vdash true : prop}}
\and
\inferrule
  {~}
  {\blum{\Omega \vdash str}}
\and
\inferrule
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a:q \vdash r}}
  {\blum{\Omega \vdash (a : q) \Rightarrow r}}
\and
\inferrule
  {\blum{\Omega \vdash j : prop}}
  {\blum{\Omega \vdash prf~j}}
\and
\inferrule
  {~}
  {\blum{\diamond \vdash}}
\and
\inferrule
  {\blum{\Omega \vdash} \\ \blum{\Omega \vdash p}}
  {\blum{\Omega, a : p \vdash}}
\end{mathpar}
\caption{Sorting, sort formation, and sort context formation}
\label{fig:sorting}
\Description[Sorting and sort formation]{Sorting and sort formation rules}
\end{figure}

Index-level judgment rules are shown in Figure \ref{fig:sorting}. A judgment of the form $\blum{\Omega \vdash q}$ means that the pre-sort $\blum{q}$ is a well-formed sort under the context $\blum{\Omega}$. A judgment of the form $\blum{\Omega \vdash}$ means that the sort pre-context $\blum{\Omega}$ is a well-formed sort context, i.e. for each binding $\blum{a : q}$ such that $\blum{\Omega} = \blum{\Omega_1, a : q, \Omega_2}$ we have $\blum{\Omega_1 \vdash q}$. Finally, a judgment $\blum{\Omega \vdash j : q}$ means that the index $\blum{j}$ has sort $\blum{q}$ under context $\blum{\Omega}$.

\subsection{Type-level static semantics}

\begin{figure}
\begin{mathpar}
\inferrule
  {\blum{\Omega,a : str} \mid \Gamma \vdash \tau : \ast}
  {\blum{\Omega} \mid \Gamma \vdash \{ [\blum{a : str}] : \tau \} : \ast}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau_i : \ast^{~i \in 1..n}}
  {\blum{\Omega} \mid \Gamma \vdash \{ \blum{s}_i : \tau_i^{~i \in 1..n} \} : \ast}
\and
\inferrule
  {\blum{\Omega,a:str \vdash i : prop}}
  {\blum{\Omega} \mid \Gamma \vdash \{ \blum{a : str} \mid \blum{i} \} : \ast}
\and
\inferrule[K-IndAbs]
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a : q} \mid \Gamma \vdash \tau : \kappa \\ a \not \in FV(\Gamma)}
  {\blum{\Omega} \mid \Gamma \vdash \lambda \blum{a : q} . \tau : \forall \blum{q} . \kappa}
\and
\inferrule
  {\blum{\Omega} \vdash \kappa \\ \blum{\Omega} \mid \Gamma,x:\kappa \vdash \tau : \rho}
  {\blum{\Omega} \mid \Gamma \vdash \lambda x : \kappa. \tau : \kappa \to \rho}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \forall \blum{q}. \ast}
  {\blum{\Omega} \mid \Gamma \vdash \bigvee \tau : \ast}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \forall \blum{q}. \rho \\ \blum{\Omega \vdash j : q}}
  {\blum{\Omega} \mid \Gamma \vdash \tau~[~\blum{j}~]: \rho}
\and
\inferrule
  {\blum{\Omega} \mid \Gamma \vdash \tau : \kappa \to \rho \\ \blum{\Omega} \mid \Gamma \vdash \sigma : \kappa}
  {\blum{\Omega} \mid \Gamma \vdash \tau~\sigma : \rho}
\and
\inferrule
  {~}
  {\blum{\Omega} \vdash \ast}
\and
\inferrule
  {\blum{\Omega \vdash q} \\ \blum{\Omega,a:q} \vdash \kappa}
  {\blum{\Omega} \vdash \forall \blu{q}. \kappa}
\and
\inferrule
  {\blum{\Omega} \vdash \kappa \\ \blum{\Omega} \vdash \rho}
  {\blum{\Omega} \vdash \kappa \to \rho}
\and
\inferrule
  {~}
  {\blum{\Omega} \vdash \diamond}
\and
\inferrule
  {\blum{\Omega} \vdash \Gamma \\ \blum{\Omega} \vdash \kappa}
  {\blum{\Omega} \vdash \Gamma, x : \kappa}
\end{mathpar}
\caption{Kinding and kind formation}
\label{fig:kinding}
\Description[Kinding and kind formation]{Kinding, kind formation, and kind context formation rules}
\end{figure}

Type-level judgment rules are shown in Figure \ref{fig:kinding}. A judgment of the form $\blum{\Omega} \vdash \kappa$ means that the pre-kind $\kappa$ is a well-formed kind under context $\blum{\Omega}$. A judgment of the form $\blum{\Omega} \vdash \Gamma$ means that $\Gamma$ is a well-formed kind context under sort context $\blum{\Omega}$. Finally, a judgment of the form $\blum{\Omega} \mid \Gamma \vdash \tau : \kappa$ means that the type $\tau$ has kind $\kappa$ under sort context $\blum{\Omega}$ and kind context $\Gamma$.

\section{Denotational Semantics}

\subsection{Index Language}

We interpret our index langauage using Dybjer's \emph{Categories-with-Families} (CwF) framework for semantically modeling dependently typed languages \cite{dybjer1995internal}. We first review the definition of CwF, then review the standard set-theoretic CwF, and finally provide an interpretation of the index language with respect to a CwF. The entirety of this section is standard. However, we rename some of the standard terminology to fit into the present setting, e.g. instead of dependent types we have dependent sorts.

\subsubsection{Categories with Families}

A Category-with-Families (CwF) consists of 
\begin{itemize}
\item A category $\mathbb C$ with a terminal object, called the \emph{category of contexts}. Objects of $\mathbb C$ are called semantic contexts and written with the symbols $\Omega$, $\Psi$, $\Upsilon$.
\item For each semantic context $\Omega$ a collection $\mathit{St}(\Omega)$ called the \emph{semantic sorts} of $\Omega$. Semantic sorts are written with the symbols $X$,$Y$, and $Z$.
\item For each semantic context $\Omega$ and $X \in \mathit{St}(\Omega)$ a collection $\mathit{In}(\Omega,X)$ called the \emph{semantic indices} of sort $X$.
\item For each arrow $f : \Omega \to \Psi$ a mapping $- \{ f \} : \mathit{St}(\Psi) \to \mathit{St}(\Omega)$. These mappings preserve composition, in the sense that we have $- \{ \mathit{id}_{\Omega} \} = \mathit{id}_{\mathit{St}(\Omega)}$, and for $g : \Psi \to \Upsilon$ we have $- \{ g \circ f \} = - \{ g \} \{ f \}$.
\item For each arrow $f : \Omega \to \Psi$ and sort $X \in \mathit{St}(\Psi)$ a mapping $- \{ f \} : \mathit{In}(\Psi,X) \to \mathit{In}(\Omega,X \{ f \})$. These mappings preserve composition in the same sense as above.
\item For each context $\Omega$ and sort $X \in \mathit{St}(\Omega)$, we have an object $\Omega . X$ of $\mathbb C$, an arrow $\frak p(X) : \Omega . X \to \Omega$, and an index $\frak v_{X} \in \mathit{In}(\Omega . X, X \{ \frak p(X) \})$ such that for all $f : \Psi \to \Omega$ and $M \in \mathit{In}(\Psi, X \{ f \})$ there exists a unique morphism $\langle f , M \rangle_X : \Psi \to \Omega . X$ such that $\frak p(X) \circ \langle f , M \rangle_X = f$ and $\frak v_{X} \{ \langle f, M \rangle_X \} = M$.
\end{itemize}

For $M \in \mathit{In}(\Omega, X)$ we write $\overline{M}$ for the arrow $\langle \mathit{id}_{\Omega}, M \rangle_X : \Omega \to \Omega.X$. 

For $f : \Psi \to \Omega$ and $X \in \mathit{St}(\Omega)$ we define $\frak q(f, X) : \Psi.X \{ f \} \to \Omega . X$, called the \emph{weakening} $f$ by $X$ as
$$\frak q(f,X) = \langle f \circ \frak p(X \{ f \}), \frak v_{X \{ f \}} \rangle_X$$

A \emph{weakening map} is a morphism of the form $\frak p(X) : \Omega . X \to \Omega$ or of the form $\frak q(w, Y)$ where $w$ is a weakening map. We write $f^+$ and $X^+$ for $f \{ w \}$ and $X \{ w \}$ when $w$ is a weakening map that is clear from context.

A CwF is said to \emph{support $\Pi$-sorts} if for any two sorts $X \in \mathit{St}(\Omega)$ and $Y \in \mathit{St}(\Omega.X)$ there is a sort $\Pi(X,Y) \in \mathit{St}(\Omega)$ and a morphism $$\mathit{App}_{X,Y} : \Omega . X . \Pi(X,Y)^+ \to \Omega . X . Y$$ such that $$\frak p(X) \circ \mathit{App}_{X,Y} = \frak p(\Pi(X,Y)^+) \hspace{3.0ex} \textit{App-T}$$
and for every $M \in \mathit{In}(\Omega.X, Y)$
$$\mathit{App}_{X,Y} \circ \overline{M \{ p(X) \}} = \overline{M} \hspace{3.0ex} \Pi\textit{-C'}$$
and for every morphism $f : B \to \Gamma$\\~\\
$\mathit{App}_{X,Y} \circ \frak q( \frak q(f, X), \Pi(X,Y)\{ \frak q (f, X) \})$\\ 
$= \frak q(\frak q (f, X), Y) \circ \mathit{App}_{X \{ f \}, Y \{ \frak q(f, \sigma) \}}$\\~\\

\subsubsection{Set-theoretic CwF}

Our index language will be interpreted using a standard set-theoretic CwF. This CwF's category of contexts is $\mbf{Sets}$, the category of sets and functions. For a set $\Omega$, $\mathit{St}(\Omega)$ is the collection of all $\Omega$-indexed families of sets. For all $\Omega$ and $X \in \mathit{St}(\Omega)$, $\mathit{In}(\Omega,X)$ is the collection of families $\fm{x_\omega \in X_\omega}{\omega \in \Omega}$ selecting an element $x_\omega \in X_\omega$ for each $\omega \in \Omega$. For all $h : \Omega \to \Psi$, $X \in \mathit{St}(\Psi)$, and $M \in \mathit{In}(\Psi,X)$ we define $X \{ h \}_{\omega} \defeq X_{f(\omega)}$ and $M \{ h \}_\omega \defeq M_{f(\omega)}$. For each $\Omega$ and $X \in \mathit{St}(\Omega)$ we define $$\Omega . X \defeq \{ (\omega,x) \mid \omega \in \Omega \text{ and } x \in X_\omega \}$$ $\frak p (X)(\omega,x) \defeq \omega$, and $(\frak v_{X})_{(\omega,x)} \defeq x$. Finally, letting $f : \Psi \to \Omega$ and $M \in \mathit{In}(\Psi, X \{ f \})$, we have $\langle f, M \rangle_X(\psi) = (f(\psi), M_{\psi})$.

\subsubsection{Interpretation}

Our index langauge is a fragment of the calculus of constructions, with the unnotable addition of strings. Its interpretation appears, for example, in Hoffman's tutorial\cite{Hofmann97syntaxand}, and is displayed in Figure \ref{fig:index-interp} for convenience. 

\begin{figure}
\begin{small}
\begin{tabular}{l}
$\sem{\blum{\diamond}} \defeq \top$ \\
$\sem{\blum{\Omega,a:q}} \defeq \sem{\blum{\Omega}}.\sem{\blum{\Omega};\blum{q}}$ if $x$ not in $\blum{\Omega}$, undefined otherwise.\\
$\sem{\blum{\Omega}; \blum{(j : q) \Rightarrow r}} \defeq \Pi(\sem{\blum{\Omega};\blum{q}},\sem{\blum{\Omega,a:q};\blum{r}})$ \\
$\sem{\blum{\Omega}; \blum{\mathbf{prf}~j}} \defeq (~\{ \ast \} \text{ if } \sem{\blum{\Omega}; \blum{j}}_\omega = \mathit{true}, \text{~}\emptyset\text{ otherwise}~)_{\omega \in \sem{\blum{\Omega}}}$ \\
$\sem{\blum{\Omega}; \blum{prop}} \defeq ( \{ \mathit{true}, \mathit{false} \} )_{\omega \in \sem{\blum{\Omega}}}$\\
$\sem{\blum{\Omega}; \blum{str}} \defeq (\text{the set of strings})_{\omega \in \sem{\blum{\Omega}}}$\\
$\sem{\blum{\Omega}; \blum{App_{[a:q],r}(i,j)}} \defeq$ \\
\hspace{1.5ex} $\mathit{App}_{\sem{\blum{\Omega;q}},\sem{\blum{\Omega,a:q;r}}} \circ \langle \overline{\sem{\blum{\Omega ; i}}}, \sem{\blum{\Omega ; j}}^+ \rangle_{\sem{\blum{\Omega ; \blum{(a : q) \to r}}}^+}$ \\
$\sem{\blum{\Omega,a \! : \! q}~;~\blum{a}} \defeq \frak{v}_{\sem{\blum{\Omega,a:q}}}$ \\
$\sem{\blum{\Omega};\blum{s}} \defeq \fm{s}{\omega \in \sem{\blum{\Omega}}}$
\end{tabular}{l}
\end{small}
\caption{Interpretation of index language}
\label{fig:index-interp}
\end{figure}

We also state the fragment of the standard soundness theorem which will be relevant in the sequel: 

\begin{theorem} Our interpretation satisfies the following properties.
\begin{itemize}
\item If $\blum{\Omega \vdash}$ then $\sem{\blum{\Omega}}$ is an object of the context category $\mathbf{Sets}$.
\item If $\blum{\Omega \vdash q}$ then $\sem{\blum{\Omega};\blum{q}}$ is an element of $\mathit{St}(\sem{\blum{\Omega}})$
\item If $\blum{\Omega \vdash j : q}$ then $\sem{\blum{\Omega ; j}}$ is an element of $\mathit{In}(\sem{\blum{\Omega}}, \sem{\blum{\Omega ; q}})$
\end{itemize}
\end{theorem}

\subsection{Type language}

%\begin{figure}
%\begin{tabular}{l}
%$\sem{\{ [\blum{a : str}] : \tau \}}_\omega \gamma \defeq$ \\
%\hspace{1em} $\{ f \in \mathit{Inst} \mid f |_s \in \sem{\tau}_{(\omega,s)} \gamma^+ \text{ if } \sem{\tau}_{(\omega,s)} \gamma^+ \text{ is non-empty }$ \\
%\hspace{5.5em} $ \text{and } f |_s = \emptyset \text{ otherwise} \}$ \\~\\
%hello
%\end{tabular}
%\end{figure}

\begin{figure}

\begin{small}
\begin{tabular}{l}
$\sem{\blum{\Omega} \vdash \ast}_\omega \defeq \mathcal P \mathcal P (\mathit{Inst})$\\
$\sem{\blum{\Omega} \vdash \forall \blum{q}. \kappa} \defeq \Pi_{\blum{\Omega},\blum{q}} \sem{\blum{\Omega, a : q} \vdash \kappa}$\\
$\sem{\blum{\Omega} \vdash \kappa \to \rho} \defeq \sem{\blum{\Omega} \vdash \kappa} \Rightarrow \sem{\blum{\Omega} \vdash \rho}$
\end{tabular}
\end{small}
\caption{Interpretation of kinding judgments}
\label{fig:kind-interp}
\end{figure}

\begin{figure*}
\begin{tabular}{l}
$\sem{\{ [\blum{a : str}] : \tau \}}_\omega \gamma \defeq \{ f \mid \forall s. f |_s \in \sem{\tau}_{(\omega,s)} \gamma^+ \text{ if } \sem{\tau}_{(\omega,s)} \gamma^+ \text{ is non-empty } \text{and } f |_s = \emptyset \text{ otherwise} \}$ \\~\\
$\sem{\{ \blum{s_i} : \tau_i^{~i \in 1..n}\}}_\omega \gamma \defeq \{ f \mid \forall i \in 1..n.~f |_{s_i} \in \sem{\tau_i}_{\omega} \gamma \}$\\~\\
$\sem{\{ \blum{a : str} \mid \blum{i} \}}_\omega \gamma \defeq \{ f \mid f(\epsilon) \! \downarrow~\wedge~~~~\sem{\blum{i}}_{(\omega, f(\epsilon))} = \mathit{true} \}$\\~\\
$\sem{\bigvee \tau}_{\omega} \gamma \defeq \bigcup_{M \in \sem{\blum{q}}_\omega} (\sem{\tau}_{\omega} \gamma)_M$
\end{tabular}

\caption{Semantics for ``non-operational'' kinding rules}
\label{fig:kindsem-direct}
\Description[Direct semantics for non-operational constructs]{Direct semantics for non-operational kinding rules}
\end{figure*}

\begin{figure}
\begin{mathpar}
\inferrule
  {f \defeq \sem{\blum{\Omega} \mid \Gamma \vdash \tau : \forall \blum{q}. \rho} : \sem{\blum{\Omega \vdash \Gamma}} \to \Pi_{\blum{\Omega}, \blum{q}} \sem{\blum{\Omega, a : q} \vdash \rho} \\ M \defeq \sem{\blum{\Omega \vdash j : q}} \in \mathit{In}(\sem{\blum{\Omega}}, \sem{\blum{\Omega \vdash q}})}
  {\sem{\blum{\Omega} \mid \Gamma \vdash \tau~[~\blum{j}~] : \rho} \defeq \overline{M}^{~*}(f^\flat)}
\and
\inferrule
  {X \defeq \sem{\blum{\Omega \vdash q}} \in \mathit{St}(\Omega) \\ 
   f \defeq \sem{\blum{\Omega,a:q} \mid \Gamma \vdash \tau : \kappa} : \frak p (X)^* \sem{\blum{\Omega} \vdash \Gamma} \to\sem{\blum{\Omega,a : q} \vdash \kappa}}
  {\sem{\blum{\Omega} \mid \Gamma \vdash \lambda \blum{a : q}. \tau : \forall \blum{q}. \kappa} \defeq 
   f^\sharp}
\end{mathpar} 

\caption{Semantics for abstraction and application}
\end{figure}

Our kinding and kind formation judgments are interpreted in terms of the fibration $\mathit{Fam}(\mbf{Sets})$. We assume basic knowledge of fibrations \cite{jacobs1999categorical}. A kind-in-sorting-context $\blum{\Omega} \vdash \kappa$ is interpreted as an object of $\mathit{Fam}(\mbf{Sets})_{\sem{\blum{\Omega}}}$, concretely a $\sem{\blum{\Omega}}$-indexed family of sets. For pre-kind contexts $\Gamma = x_1:\kappa_1,\ldots,x_n : \kappa_n$, the kinding context formation judgment $\blum{\Omega} \vdash \Gamma$ is interpreted as the product $\sem{\blum{\Omega} \vdash \kappa_1} \times \cdots \times \sem{\blum{\Omega} \vdash \kappa_n}$ in $\mathit{Fam}(\mbf{Sets})_{\sem{\blum{\Omega}}}$. A kinding judgment $\blum{\Omega} \mid \Gamma \vdash \tau : \kappa$ is interpreted as a arrow of $\mathit{Fam}(\mbf{Sets})_{\sem{\blum{\Omega}}}$ from $\sem{\blum{\Omega} \vdash \Gamma}$ to $\sem{\blum{\Omega} \vdash \kappa}$. 

\subsubsection{Dependent Simple Products}

\begin{figure}

\[\begin{tikzcd}
	{\mathbb E_\Omega} && {\mathbb E_\Psi} \\
	\\
	{\mathbb E_{\Omega.X}} && {\mathbb E_{\Psi . X \{ u \}}}
	\arrow["{\frak p(X)^*}"', curve={height=12pt}, from=1-1, to=3-1]
	\arrow["{\Pi_{X}}"', curve={height=12pt}, from=3-1, to=1-1]
	\arrow["{u^*}", from=1-1, to=1-3]
	\arrow["{\frak q(u,X)^*}"', from=3-1, to=3-3]
	\arrow["{\frak p(X \{ u \})^*}"', curve={height=12pt}, from=1-3, to=3-3]
	\arrow["{\Pi_{X \{ u \}}}"', curve={height=12pt}, from=3-3, to=1-3]
\end{tikzcd}\]
\caption{Some components of Beck-Chevalley for dependent simple products}
\label{fig:beck-chevalley}
\Description[Beck-Chevalley condition for dependent simple products]{A Beck-Chevalley condition for dependent simple products}
\end{figure}


We define a \emph{CwF-fibration} as a pair $(\mathcal C, p)$ where $\mathcal C$ is a CwF and $p : \mathbb E \to \mathbb C$ is a fibration whose base category $\mathbb C$ is $\mathcal C$'s context category.

We say that a CwF-fibration has \emph{dependent simple products} if 
\begin{itemize}
\item For all contexts $\Omega$ and all $X \in \mathit{St}(\Omega)$ the functor $\frak p (X)^*$ has a right adjoint $\Pi_{X}$. (We write $(-)^\sharp$ for the transposition from $\frak p(X)^*(A) \to B$ to $A \to \Pi_X(B)$, and $(-)^\flat$ for transposition in the opposite direction.)
\item The above adjunction satisfies a \emph{transpose distribution} property: for contexts $\Omega,\Psi$, context arrows $u : \Psi \to \Omega$, sorts $X \in \mathit{St}(\Omega)$, total objects $\Gamma$ over $\Omega$, total objects $\Delta$ over $\Omega . X$, and total arrows $f : \frak p(X)^*(\Gamma) \to \Delta$. We have $u^*f^\sharp \cong (\frak q(u, X)^* f)^\sharp$.
\item For every $u : \Psi \to \Omega$ and $X \in \mathit{St}(\Omega)$ the canonical natural transformation $u^* \Pi_{X} \Longrightarrow \Pi_{X \{ u \}} \frak q(u, X)^*$ is an isomorphism. This is typically called a \emph{Beck-Chevalley condition}.
\end{itemize}

It is a standard fact of fibrations that for arrows $u : \Omega \to \Psi$ and $v : \Psi \to \Upsilon$ of the base category, we have $u^*v^* \cong (v \circ u)^*$. From this we derive a natural isomorphism $\frak q(u,X)^* \frak p(X)^* \cong \frak p(X \{ u \})^* u^*$, which will clarify the second and third points:\\

$\frak q(u,X)^* \frak p(X)^*$\\
$\cong \langle u \circ \frak p^*(X \{ u \}), \frak v_{X \{ u \}} \rangle_X^* \frak p(X)^*$\\
$= (\frak p(X) \circ \langle u \circ \frak p^*(X \{ u \}), \frak v_{X \{ u \}} \rangle_X)^*$\\
$= (u \circ \frak p(X \{ u \})^*)^*$\\
$\cong \frak p(X \{ u \})^* u^*$\\

In the second point, it is not immediately clear that the right-hand side of the isomorphism is ``well-typed''. However, applying our isomorphism to the domain of $\frak q(z, X)^* f$ gives $\frak q(u,X)^* \frak p(X)^*(\Gamma) \cong \frak p(X \{ u \})^* u^*(\Gamma)$. Agreement of codomains follows from the Beck-Chevalley condition.

In the third point, the \emph{canonical transformation} is obtained as the transpose of
$$\frak p(X \{u \})^* u^* \Pi_X \overset{\cong}{\to} \frak q(u,X)^* \frak p(X)^* \Pi_X \overset{\frak q(u,X) \epsilon}{\to} \frak q(u,X)^*$$

\subsubsection{Set-theoretic Dependent Simple Products}

In our set-theoretic model, for semantic contexts $\Omega$ and semantic sorts $X \in \mathit{St}(\Omega)$, we define $\Pi_X : \mathit{Fam}(\mbf{Sets})_{\Omega . X} \to \mathit{Fam}(\mbf{Sets})_{\Omega}$ as:\\~\\
\begin{small}
\begin{tabular}{l}
$\Pi_{X}(\fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}) \defeq \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega}$\\
$\Pi_{X} \fm{f_{(\omega,x)} : B_{(\omega,x)} \to C_{(\omega,x)}}{(\omega,x) \in \Omega .X} \defeq \fm{\Pi_{x \in X_\omega} \hspace{2.0ex} f_{(\omega,x)}}{\omega \in \Omega}$
\end{tabular}
\end{small}
We show that $\Pi_X$ is the right adjoint of $\frak p(X)^*$ in Appendix \ref{sec:beck-chevalley},
with an underlying correspondence 
\begin{prooftree}
\AxiomC{$(A_\omega)_{\omega \in \Omega} \longrightarrow \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega} = \Pi_{X} \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$}
\doubleLine
\UnaryInfC{$\frak p (X)^* \fm{A_\omega}{\omega \in \Omega} = \fm{A_\omega}{(\omega,x) \in \Omega . X} \longrightarrow \fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}$}

\end{prooftree}
From top to bottom, $(-)^\flat$ takes an arrow $$\fm{\langle f_{(\omega,x)} : A_\omega \to B_{(\omega,x)} \rangle_{x \in X_\omega}}{\omega \in \Omega}$$ to $$\fm{f_{(\omega,x)} : A_\omega \to B_{(\omega,x)}}{(\omega,x) \in \Omega.X}$$
From bottom to top, $(-)^\sharp$ takes an arrow $$(f_{(\omega,x)} : A_\omega \to B_{(\omega,x)})_{(\omega,x) \in \Omega . X}$$ to $$\fm{\Pi_{x \in X_\omega} f_{(\omega,x)}}{\omega \in \Omega}$$ 

In this set-theoretic model, we have that $\Pi_{X \{ u \}} \frak q (u, X)^* = u^* \Pi_{X}$, and furthermore that the canonical transformation is the identity at this functor. Clearly, then, this model satisfies the Beck-Chevalley condition for dependent simple products. % double check this

\subsection{Interpretation}

Blah blah blah.

Our interpretation satisfies the following soundness theorems.

\bibliography{pldi_schema_kindcheck} 

\appendix

\onecolumn

\section{Set-theoretic Dependent Simple Products}

\subsection{The Transpose Distribution Property}

Here we show that dependent simple products in the standard set-theoretic model satisfy the transpose distribution property.

For contexts $\Omega$, $\Psi$, arrows $u : \Psi \to \Omega$, semantic sorts $X \in \mathit{St}(\Omega)$, total objects $A$ over $\Omega$, and total objects $B$ over $\Omega . X$,  
an arrow $f : \frak p(X)^*(A) \to B$ has the form

$$\fm{f_{(\omega,x)} : A_{\omega} \to B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$$
We then have:\\~\\
$u^* f^\sharp$ \\
$u^* \fm{f_{(\omega,x)}}{(\omega,x) \in \Omega . X}^\sharp$ \\
$= u^* \fm{\langle f_{(\omega, x)} \rangle_{x \in X_\omega}}{\omega \in \Omega}$ \\
$= \fm{ \fm{f_{(u(\psi), x)}}{x \in X_{u(\psi)}}}{\psi \in \Psi}$\\
$= \fm{ \fm{f_{(u(\psi), x)}}{x \in X_{u(\psi)}}}{(\psi, x) \in \Psi . X \{ u \}}^\sharp$\\
$= (\langle u \circ \frak p(X \{ u \}), \frak v_{X \{ u \}} \rangle_X^* \fm{f_{(\omega,x)}}{(\omega,x) \in \Omega . X})^\sharp$\\
$= (\langle u \circ \frak p(X \{ u \}), \frak v_{X \{ u \}} \rangle_X^* f)^\sharp$\\
$= (\frak q(u,X)^* f)^\sharp$

\subsection{The Beck-Chevalley Condition}

\label{sec:beck-chevalley}

In our set-theoretic model, the canonical natural transformation of dependent simple products is an identity and therefore satisfies the Beck-Chevalley condition. We proceed to demonstrate this.

For semantic contexts $\Omega$ and sorts $X \in \mathit{St}(\Omega)$, we define $\Pi_{X} : \mathit{Fam}(\mbf{Sets})_{\Omega . X} \to \mathit{Fam}(\mbf{Sets})_{\Omega}$ as

\begin{small}
\begin{tabular}{l}
$\Pi_{X}(\fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}) = \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega}$\\
$\Pi_{X} \fm{f_{(\omega,x)} : B_{(\omega,x)} \to C_{(\omega,x)}}{(\omega,x) \in \Omega .X} = \fm{\Pi_{x \in X_\omega} \hspace{2.0ex} f_{(\omega,x)}}{\omega \in \Omega}$
\end{tabular}
\end{small}

We have a bijection of the following form. 
\begin{prooftree}\\~\\
\AxiomC{$(A_\omega)_{\omega \in \Omega} \longrightarrow \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega} = \Pi_{X} \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$}
\doubleLine
\UnaryInfC{$\frak p (X)^* \fm{A_\omega}{\omega \in \Omega} = \fm{A_\omega}{(\omega,x) \in \Omega . X} \longrightarrow \fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}$}

\end{prooftree}~\\~\\
From top to bottom, this bijection, which we'll call $(-)^\flat$, takes an arrow $$\fm{\langle f_{(\omega,x)} : A_\omega \to B_{(\omega,x)} \rangle_{x \in X_\omega}}{\omega \in \Omega}$$ to $$\fm{f_{(\omega,x)} : A_\omega \to B_{(\omega,x)}}{(\omega,x) \in \Omega.X}$$
From bottom to top, $(-)^\flat$'s inverse $(-)^\sharp$ takes an arrow $$(f_{(\omega,x)} : A_\omega \to B_{(\omega,x)})_{(\omega,x) \in \Omega . X}$$ to $$\fm{\Pi_{x \in X_\omega} f_{(\omega,x)}}{\omega \in \Omega}$$ 

$(-)^\flat$ underlies an adjunction $\frak p(X)^* \dashv \Pi_{\Omega, X}$. To prove this, first consider an arrow $g$, where $$g = \fm{g_{\omega}}{(\omega) \in \Omega} : \fm{C_{\omega}}{\omega \in \Omega} \to \fm{A_\omega}{\omega \in \Omega}$$
and a arrow $f$ where
$$f = \fm{f_{(\omega,x)}}{(\omega,x) \in \Omega . X} : \fm{A_\omega}{(\omega,x) \in \Omega . X} \to \fm{B_{(\omega, x)}}{(\omega,x) \in \Omega . X}$$
We then have\\~\\
$(f \circ \frak p^*(g))^\sharp$\\
$= ( \fm{f_{(\omega,x)} \circ g_{\omega}}{(\omega,x) \in \Omega.X} )^\sharp$\\
$= \fm{\Pi_{x \in X_{\omega}}~~~f_{(\omega,x)} \circ g_\omega}{\omega \in \Omega}$\\
$= \fm{(\Pi_{x \in X_{\omega}}~~~f_{(\omega,x)}) \circ g_\omega}{\omega \in \Omega}$\\
$= f^\sharp \circ g$\\~\\
Next, consider a arrow $f$, where
$$f = \fm{\langle f_{(\omega,x)} \rangle_{x \in X_\omega}}{\omega \in \Omega} : \fm{A_\omega}{\omega \in \Omega} \to \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega}$$
and a arrow $g$, where
$$g = \fm{g_{(\omega,x)}}{(\omega,x) \in \Omega . X} : \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X} \to \fm{D_{(\omega,x)}}{(\omega,x) \in \Omega . X}$$
We then have\\~\\
$(\Pi_{X}(g) \circ f)^\flat$\\
$= ( \fm{\langle g_{(\omega, x)} \circ f_{(\omega,x)} \rangle_{x \in X_\omega} }{\omega \in \Omega} )^\flat$\\ 
\vspace{0.5ex}$= \fm{g_{(\omega, x)} \circ f_{(\omega,x)}}{(\omega, x) \in \Omega . X}$\\
$= g \circ f^\flat$\\~\\
To obtain the counit of this bijection at component $\fm{B_{(\omega, x)}}{(\omega,x) \in \Omega.X}$, writing $\pi_x$ for the projection $\Pi_{x \in X_\omega} B_{(x,\omega)} \to B_{(x,\omega)}$, we map the identity arrow $$\fm{\langle \pi_x \rangle_{x \in X_\omega}}{\omega \in \Omega} : \Pi_X \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega} \to \Pi_X \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega}$$ through $(-)^\flat$, obtaining the counit $\epsilon$ as $$\fm{\pi_{(\omega,x')} : \Pi_{x \in X_\omega} B_{(\omega,x)} \to B_{(\omega,x')}}{(\omega,x') \in \Omega . X}$$ It is a arrow of type
$$\frak p(X)^* \Pi_X \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X} \longrightarrow \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$$

To prove the Beck-Chevalley condition, we must first concretely describe the canonical natural transformation $u^* \Pi_X \Longrightarrow \Pi_{X \{ u \}} \frak q(u,X)^*$. As a first step, we concretely describe the natural transformation
$$\frak p(X \{u \})^* u^* \Pi_X \overset{\cong}{\to} \frak q(u,X)^* \frak p(X)^* \Pi_X \overset{\frak q(u,X) \epsilon}{\to} \frak q(u,X)^*$$
at component $\fm{B_{(\omega,x)}}{(\omega,x) \in \Omega.X}$\\~\\
$\frak p(X \{ u \})^* u^* \Pi_X \fm{B_{\omega,x}}{(\omega,x) \in \Omega.X}$\\
$= \frak p(X \{ u \})^* u^* \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{\omega \in \Omega}$\\
$= \frak p(X \{ u \})^* \fm{\Pi_{x \in X_{u(\psi)}} B_{(u(\psi),x)}}{\psi \in \Psi}$\\
$= \fm{\Pi_{x \in X_{u(\psi)}} B_{(u(\psi),x)}}{(\psi,x') \in \Psi . X \{ u \}}$ \\
$= \fm{\Pi_{x \in X_{\pi \langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle (\psi,x')}} B_{(\pi \langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle (\psi,x'),x)}}{(\psi,x') \in \Psi . X \{ u \}}$\\
$= \langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle^* \fm{\Pi_{x \in X_{\pi (\omega,x')}} B_{(\pi (\omega,x'),x)}}{(\omega,x') \in \Omega . X}$\\
\vspace{1.5ex} $= \langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle^* \fm{\Pi_{x \in X_\omega} B_{(\omega,x)}}{(\omega,x') \in \Omega . X}$
\[\begin{tikzcd}
	{} \\
	{} \\
	\arrow["{\langle u \circ \frak p(X \{ u \}), \frak v_{X \{u \}}\rangle^*(\pi_{(\omega, x')})_{(\omega, x') \in \Omega . X}}", from=1-1, to=3-1]
\end{tikzcd}\]
$\langle u \circ \frak p(X \{ u \})  , \frak v_{X \{ u \}} \rangle^* \fm{B_{(\omega,x')}}{(\omega,x') \in \Omega . X}$
\\~\\
The above arrow is equal to 
$$\fm{\pi_{(u(\psi),x')} : \Pi_{x \in X_{u(\psi)}} B_{(u(\psi),x)} \to B_{(u(\psi),x')}}{(\psi, x') \in \Psi . X \{ u \}}$$
Transposing gives
$$\fm{\Pi_{x' \in X_{u(\psi)}}~(\pi_{(u(\psi),x')} : (\Pi_{x \in X_{u(\psi)}} B_{(u(\psi),x)}) \to B_{(u(\psi),x')})}{\psi \in \Psi}$$
This is the identity arrow on the object 
$$\fm{\Pi_{x' \in X_{u(\psi)}} B_{(u(\psi), x')}}{\psi \in \Psi}$$
which has the following ``type signature'' 
$$\Pi_{X \{ u \}} \frak q(u, X)^* \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X} \longrightarrow u^* \Pi_X \fm{B_{(\omega,x)}}{(\omega,x) \in \Omega . X}$$
Because it is an identity, it is clearly invertible.

\section{Substitution lemmas}

We first reproduce some standard definitions and theorems from the semantics of dependent types. These definitions and lemmas will subsequently be used to establish our own soundness proofs.

\begin{lemma}
\label{lemma:indsortsub-syntax}
If $\blum{\Omega, a:p,\Psi \vdash q}$ and $\blum{\Omega \vdash j : p}$ then $\blum{\Omega, \Psi[j/a] \vdash q[j/a]}$.
\end{lemma}

\begin{proof}
TODO
\end{proof} 
For pre-contexts $\blum{\Omega},\blum{\Psi}$ and pre-sorts $\blum{q},\blum{r}$ we define the expression $\mbf{P}(\blum{\Omega};\blum{p};\blum{\Psi})$ inductively by
\begin{center}

\begin{tabular}{l}
$\mbf{P}(\blum{\Omega}; \blum{q}; \blum{\diamond}) \defeq \frak p(\sem{\blum{\Omega; p}})$\\
$\mbf{P}(\blum{\Omega}; \blum{q}; \blum{\Psi,a \! : \! r}) \defeq \frak q (\mbf{P}(\blum{\Omega} ; \blum{q} ; \blum{\Psi}),\sem{\blum{\Omega},\blum{\Psi};\blum{r}})$
\end{tabular}
\end{center}

The idea is that $\mbf{P}(\blum{\Omega} ; \blum{q} ; \blum{\Psi})$ is a morphism from $\sem{\blum{\Omega}, \blum{a : q}, \blum{\Psi}}$ to $\sem{\blum{\Omega},\blum{\Psi}}$ projecting the $\blum{q}$ part. \\

Now let $\blum{\Omega},\blum{\Psi},\blum{p},\blum{q}$ be as before and $\blum{i}$ a pre-index. We define

\begin{center}
\begin{tabular}{l}
$\mbf{T}(\blum{\Omega};\blum{q};\blum{\blum{\diamond}};\blu{i}) \defeq \overline{\sem{\blum{\Omega;i}}}$\\
$\mbf{T}(\blum{\Omega};\blum{q};\blum{\Psi},\blu{a \! : \! r};\blum{i}) \defeq \frak q (\mbf{T}(\blum{\Omega};\blum{q};\blum{\Psi};\blum{i}), \sem{\blum{\Omega},\blum{b : q}, \blum{\Psi}; \blu{r}}) \hspace{3.5ex} \blum{b} \text{ fresh}$
\end{tabular}
\end{center}

The idea here is that $\mbf{T}(\blum{\Omega} ; \blum{q} ; \blum{\Psi} ; \blum{i})$ is a morphism from $\sem{\blum{\Omega},\blum{\Psi}[\blum{i}/\blum{b}]}$ to $\sem{\blum{\Omega}, \blum{b} : \blum{q}, \blum{\Psi}}$ yielding $\sem{\blum{\Omega} ; \blum{i}}$ at the $\blum{b \! : \! \blum{q}}$ position and variables otherwise.\\~\\
The above ideas must be proven simultaneously in the form of weakening and substitution lemmas.

\begin{lemma}
(Weakening) Let $\blum{\Omega},\blum{\Psi}$ be pre-contexts, $\blum{p},\blum{q}$ pre-sorts, $\blum{i}$ a pre-index, and $\blum{b}$ a fresh variable. Let $\blum{A} \in \{ \blum{p}, \blum{i} \}$. The expression $\mbf{P}(\blum{\Omega} ; \blum{p} ; \blum{\Psi})$ is defined iff $\sem{\blum{\Omega}, \blum{p \! : \! q}, \blum{\Psi}}$ and $\sem{\blum{\Omega}, \blum{\Psi}}$ are defined and in this case is a morphism from the former to the latter. If $\sem{\blum{\Omega},\blum{\Psi} ; \blum{A}}$ is defined then 
$$\sem{\blum{\Omega}, \blum{b \! : \! p}, \blum{\Psi} ; \blum{A}} \simeq \sem{\blum{\Omega} , \blum{\Psi} ; \blum{A}} \{ \mbf{P}(\blum{\Omega}; \blum{p} ; \blum{\Psi}) \}$$
\end{lemma}

\begin{lemma}
\label{lemma:indsortsub}
(Substitution) Let $\blum{\Omega},\blum{\Psi}$ be pre-contexts, $\blum{p},\blum{q}$ pre-sorts, $\blum{i}, \blum{j}$ pre-indices, and $\blum{b}$ a fresh variable. Let $\blum{A} \in \{ \blum{p}, \blum{i} \}$ and suppose that $\sem{\blum{\Omega} ; \blum{i}}$ is defined. 

The expression $\mbf{T}(\blum{\Omega};\blum{p};\blum{\Psi};\blum{i})$ is defined iff $\sem{\blum{\Omega}, \blum{\Psi}[\blum{i}/\blum{b}]}$ and $\sem{\blum{\Omega} , \blum{b \! : \! p}, \blum{\Psi}}$ are both defined and in this case is a morphism from the former to the latter. If $\sem{\blum{\Omega},\blum{b \! : \! p},\blum{\Psi} ; \blum{A}}$ is defined then 
$$\sem{\blum{\Omega},\blum{\Psi}[\blum{i}/\blum{b}]; \blum{A}[\blum{i}/\blum{b}]} \simeq \sem{\blum{\Omega},\blum{b} \! : \! \blum{p},\blum{\Psi};\blum{A}} \{ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi} ; \blum{i}) \}$$
\end{lemma}

\begin{proof}
TODO
\end{proof}

Now that the above standard lemmas have been established, we state and prove our substitution lemmas.

\begin{lemma}
If $\blum{\Omega,a : p, \Psi} \vdash \kappa$ and $\blum{\Omega \vdash j : p}$ then $\blum{\Omega, \Psi[j/a]} \vdash \kappa[\blum{j}/\blum{a}]$
and $$\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \sem{\blum{\Omega,a:p,\Psi} \vdash \kappa} \cong \sem{\blum{\Omega, \Psi[j/a]} \vdash \kappa[\blum{j}/\blum{a}]}$$
\end{lemma}

\begin{proof}
By induction on the proof of $\blum{\Omega,a : p, \Psi} \vdash \kappa$.\\
\begin{description}
\item[Case \begin{sc}WFK-IndAbs\end{sc}:]~\\
We have $\kappa = \forall \blum{q}. \kappa'$. Our premises are $\blum{\Omega,a : p, \Psi \vdash q}$ and $\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \kappa'$.
Applying lemma \ref{lemma:indsortsub-syntax} we have $\blum{\Omega, \Psi[j/a] \vdash q[j/a]}$ and hence $\sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} \downarrow$.
By lemma \ref{lemma:indsortsub} we have $$\sem{\blum{\Omega,a:p,\Psi \vdash q}} \{ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi} ; \blu{j}) \} = \sem{\blum{\Omega,\Psi[\blum{j}/\blum{a}] \vdash q[\blum{j}/\blum{a}]}}$$
Applying the IH to the second premise we have
$$\blum{\Omega,\Psi[j/a],b : q[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \kappa'[\blum{j}/\blum{a}]$$
and
$$ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi}, \blum{b : q} ; \blu{j})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \kappa'} \cong \sem{\blum{\Omega, \Psi[\blum{j}/a], b : q[\blum{j}/\blum{a}]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \kappa'[\blum{j}/\blum{a}]} $$
Applying \begin{sc}WFK-IndAbs\end{sc} we get
\begin{mathpar}
\inferrule
  {\blum{\Omega,\Psi[j/a] \vdash q[j/a]} \\ \blum{\Omega,\Psi[j/a],b : q[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \kappa'[\blum{j}/\blum{a}]}
  {\blum{\Omega,\Psi[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}
\end{mathpar}

Additionally, we have\\~\\
\begin{align*}
 &\quad \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \sem{\blum{\Omega,a:p,\Psi} \vdash \forall \blum{q}. \kappa'}\\
=&\qquad \text{\{ Interpretation of \begin{sc}KF-Forall\end{sc} \}} \\
 &\quad \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \Pi_{\sem{\blum{\Omega, a : p, \Psi \vdash q}}} \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}\\
\cong&\qquad \text{\{ Beck-Chevalley For Dependent Simple Products, taking } \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) \text{ as } u \}\\
 &\quad \Pi_{ \sem{\blum{\Omega, a : p, \Psi \vdash q}} \{ \mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) \} } \frak q(\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) , \sem{\blum{\Omega, a:p, \Psi \vdash q}})^* \sem{\blum{\Omega,a:p,\Psi,b : q} \vdash \kappa'}\\
=&\qquad \text{ \{ Lemma \ref{lemma:indsortsub} \}}\\
 &\quad \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \frak q(\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j}) , \sem{\blum{\Omega, a:p, \Psi \vdash q}})^* \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}\\
=&\qquad \text{\{ Definition of } \mbf{T} \}\\
 &\quad \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \mbf T(\blum{\Omega}; \blum{p} ; \blum{(\Psi, a : q)}; \blum{j})^* \sem{\blum{\Omega,a:p,\Psi,b:q} \vdash \kappa'}\\
=&\qquad \text{\{ IH \}} \\ 
 &\quad \Pi_{ \sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} } \sem{\blum{\Omega,\Psi[j/a],b:q[j/a]} \vdash \kappa'[\blum{j}/\blum{a}]}\\
=&\qquad \text{\{ Interpretation of \begin{sc}KF-Forall\end{sc} \}}\\
 &\quad \sem{\blum{\Omega,\Psi[j/a]} \vdash \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}\\
=&\qquad \text{\{ Definition of Index-to-Type Substitution \}}\\
 &\quad \sem{\blum{\Omega,\Psi[j/a]} \vdash (\forall \blum{q}. \kappa')[\blum{j}/\blum{a}]}
\end{align*}

\item[Other cases:]~\\
TODO
\end{description}

\end{proof}


\begin{lemma}
If $\blum{\Omega,a : p, \Psi} \mid \Gamma \vdash \tau : \kappa$ and $\blum{\Omega \vdash j : p}$ then $\blum{\Omega, \Psi[j/a]} \mid \Gamma[\blum{j}/\blum{p}] \vdash \tau[\blum{j}/\blum{p}] : \kappa[\blum{j}/\blum{p}]$ and
$$\mbf{T}(\blum{\Omega} ; \blum{a : p} ; \blum{\Psi} ; \blu{j})^* \sem{\blum{\Omega, a:p, \Psi} \mid \Gamma \vdash \tau : \kappa} \cong \sem{\blum{\Omega, \Psi[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau[\blum{j}/\blum{a}] : \kappa[\blum{j}/\blum{a}]}$$
\end{lemma}

\begin{proof}
By induction on the proof of $\blum{\Omega, a : p, \Psi} \mid \Gamma \vdash \tau : \kappa$.
\begin{description}
\item [Case \sc{K-IndAbs}:]~\\
We have $\tau = \lambda \blum{b : q}. \tau'$ and $\kappa = \forall \blum{q}. \kappa'$. Our premises are $\blum{\Omega, a:p, \Psi \vdash q}$ and $\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'$.
Applying lemma \ref{lemma:indsortsub-syntax} we have $\blum{\Omega, \Psi[j/a] \vdash q[j/a]}$ and hence $\sem{\blum{\Omega, \Psi[j/a] \vdash q[j/a]}} \downarrow$.
By lemma \ref{lemma:indsortsub} we have $$\sem{\blum{\Omega,a:p,\Psi \vdash q}} \{ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi} ; \blu{j}) \} = \sem{\blum{\Omega,\Psi[\blum{j}/\blum{a}] \vdash q[\blum{j}/\blum{a}]}}$$
Applying the IH to the second premise we have $$\blum{\Omega, \Psi[\blum{j}/\blum{a}], b : q[\blum{j}/\blum{a}]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau'[\blum{j}/\blum{a}] : \kappa'[\blum{j}/\blum{a}]$$
and
$$ \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi}, \blum{b : q} ; \blu{j})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'} \cong \sem{\blum{\Omega, \Psi[\blum{j}/a], b : q[\blum{j}/\blum{a}]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau'[\blum{j}/\blum{a}] : \kappa'[\blum{j}/\blum{a}]} $$
Now, applying the \begin{sc}K-IndAbs\end{sc} rule, we get
\begin{mathpar}
\inferrule
  {\blum{\Omega,\Psi[j/a] \vdash q[j/a]} \\ \blum{\Omega,\Psi[j/a],b : q[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau'[\blum{j}/\blum{a}] : \kappa'[\blum{j}/\blum{a}]}
  {\blum{\Omega,\Psi[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \lambda \blum{b : q[j/a]}. \tau'[\blum{j}/\blum{a}] : \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}
\end{mathpar} 

We also have

\begin{align*}
 &\quad \sem{\blum{\Omega, \Psi'[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash (\lambda \blum{b : q}. \tau')[\blum{j}/\blum{a}] : (\forall \blum{q}. \kappa')[\blum{j}/\blum{a}]}\\
=&\qquad \{ \text{Definition of substitution} \}\\
 &\quad \sem{\blum{\Omega, \Psi'[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \lambda \blum{b : q[j/a]}. \tau'[\blum{j}/\blum{a}] : \forall \blum{q[j/a]}. \kappa'[\blum{j}/\blum{a}]}\\
=&\qquad \{ \text{Interpretation of \begin{sc}K-IndAbs\end{sc}} \} \\
 &\quad \sem{\blum{\Omega,\Psi'[j/a], b : q[j/a]} \mid \Gamma[\blum{j}/\blum{a}] \vdash \tau'[\blum{j}/\blum{a}] : \kappa'[\blum{j} / \blum{a}] }^\sharp\\
\cong&\qquad \{ \text{IH} \}\\
 &\quad (\mbf{T}(\blum{\Omega}; \blum{p} ; \blum{(\Psi, b:q)} ; \blum{j})^* \sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'})^\sharp\\
\cong&\qquad \{ \text{Transpose distribution} \} \\
 &\quad \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi} ; \blum{j})^*\sem{\blum{\Omega, a : p, \Psi, b : q} \mid \Gamma \vdash \tau' : \kappa'}^\sharp\\
=& \qquad \{ \text{Interpretation of \begin{sc}K-IndAbs\end{sc}} \}\\
 &\quad \mbf{T}(\blum{\Omega} ; \blum{p} ; \blum{\Psi} ; \blum{j})^*\sem{\blum{\Omega, a : p, \Psi} \mid \Gamma \vdash \lambda \blum{b : q}. \tau' : \forall \blum{q}. \kappa'}
\end{align*}

\item[Other cases:]~\\
TODO.
\end{description}

\end{proof}

\section{An Order-Theoretic Model (and Redesign)}

To avoid dangling foreign keys, industrial databases often avoid removing data entries, giving their evolution over time an inflationary character. In such a situation we can interpret the sort $\blum{prop}$ as the ordinal $\mbf{2}$, containing the two elements $\mathit{known}$ and $\mathit{unknown}$, ordered such that $\mathit{unknown} \leq \mathit{known}$. A predicate $\blum{P : str \to prop}$ then represents a set of elements such that membership in the set is either known (definitely a member) or undetermined (may or may not be a member).

\subsection{Contexts, Sorts, Indices, and Subsitution}

We capture the above intuition with a CwF. Its category of contexts is $\mbf{Posets}$. For semantic contexts $P$, we define $\mathit{St}(\Omega)$ (read the \emph{semantic sorts} of context $\Omega$) as the collection of $\Omega$-indexed families of posets. Such a family $\fm{X_\omega}{\omega \in \Omega}$ is a poset-indexed family rather than a set-indexed family; i.e., for $\omega_1,\omega_2 \in \Omega$ with $\omega_1 \leq \omega_2$ we have a chosen monotone injection $i_{\omega_1 \leq \omega_2} : X_{\omega_1} \to X_{\omega_2}$ such that for $\omega \in \Omega$ we have $i_{\omega \leq \omega} = \mathit{id}_{X_\omega}$ and for $\omega_1 \leq \omega_2 \leq \omega_3$ we have $i_{\omega_1 \leq \omega_3} = i_{\omega_2 \leq \omega_3} \circ i_{\omega_1 \leq \omega_2}$.
A poset-indexed family of posets $\fm{X_\omega}{\omega \in \Omega}$ can itself be considered a poset whose elements are families $\fm{M_\omega \in X_\omega}{\omega \in \Omega}$ and $\fm{M_\omega}{\omega \in \Omega} \leq \fm{M_\omega'}{\omega \in \Omega} \Leftrightarrow (M_\omega \leq M_\omega')$ for all $\omega \in \Omega$.

For semantic contexts $\Omega$ and all $X \in \mathit{St}(P)$ we define $\mathit{In}(P, X)$ as the collection of all $\Omega$-indexed families $(M_\omega \in X_\omega)_{\omega \in \Omega}$ such that for $\omega_1 \leq_P \omega_2$ we have $i(M_{\omega_1}) \leq_{X_{\omega_2}} M_{\omega_2}$.

For each monotone function $f : \Omega \to \Psi$ we define a sort-level semantic substitution operator $- \{ f \} : \mathit{St}(\Psi) \to \mathit{St}(\Omega)$ as 
$$X \{ f \} \defeq \fm{X_{f(\omega)}}{\omega \in \Omega}$$
For $\omega_1 \leq \omega_2$ we have $f(\omega_1) \leq f(\omega_2)$ and so our chosen monotone injection is 
$$i_{\omega_1 \leq \omega_2} : X\{ f \}_{\omega_1} \to X \{ f \}_{\omega_2} \defeq i_{f(\omega_1) \leq f(\omega_2)}$$

For $X \in \mathit{St}(\Psi)$ a index-level semantic substution operator $- \{ f \} : \mathit{In}(\Psi,X) \to \mathit{In}(\Omega, X \{ f \})$.

\subsection{Comprehensions}

Let $\Omega$ be a semantic context and $X$ a semantic sort in context $\Omega$. The comprehension $\Omega . X$ is the poset of pairs $(\omega,x)$ with $\omega \in \Omega$ and $x \in X_\omega$ such that 
$$(\omega_1,x_1) \leq_{\Omega.X} (\omega_2,x_2) \defequiv (\omega_1 \leq \omega_2) \wedge (i(x_1) \leq x_2)$$
We have a monotone function $\frak p(X) : \Omega . X \to \Omega$ defined as 
$$\frak p(X)(\omega,x) \defeq \omega$$
and also a semantic index term $\frak v_X \in \mathit{In}(\Omega.X, X \{ \frak p(X) \})$ defined as
$$\fm{\frak v_X}{ (\omega,x) } \defeq x$$
\begin{lemma}
Let $f : \Omega \to \Psi$ be a monotone function, $X \in \mathit{St}(\Psi)$, and $M \in \mathit{In}(\Omega, X \{ f \})$. Then there exists a unique morphism $\langle f, M \rangle_X : \Omega \to \Psi.X$ satisfying $\frak p(X) \circ \langle f, M \rangle_X = f$ and $\frak v_{X}\{ \langle f, M \rangle_X \} = M$.  
\end{lemma}

\begin{proof}
The morphism is
$$\omega \overset{\langle f, M \rangle_X}{\mapsto} (f(\omega), M_{\omega})$$
Clearly we have $\frak p(X) \circ \langle f, M \rangle_X = f$ since
$$\omega \overset{\langle f, M \rangle_X}{\mapsto} (f(\omega), M_{\omega}) \overset{\frak p(X)}{\mapsto} f(\omega)$$
Also, we have $\frak v_X \{ \langle f, M \rangle_X \} = M$ since
$$\frak v_X \{ \langle f, M \rangle_X \}_\omega = (\frak v_X)_{\langle f , M \rangle_X(\omega)} = (\frak v_X)_{(f(\omega), M_\omega)} = M_\omega$$
Also, $\langle f, M \rangle_X$ is monotone since if $\omega \leq \omega'$ we have
$$\langle f, M \rangle_X (\omega) = (f(\omega), M_\omega) \leq (f(\omega'), M_{\omega'}) = \langle f, M \rangle_X (\omega')$$
(Reminder: Since $M \in X \{ f \}$ we have $M_\omega \in X_{f(\omega)}$.)\\~\\
TODO: prove uniqueness
\end{proof}

\subsection{$\Pi$-sorts}

This model does not have arbitrary $\Pi$-sorts. However, identifying the \emph{pointed sorts} $\mathit{PSt}(\Omega)$ as those families of posets over $\Omega$ whose component posets all have $\bot$ (minimum) elements, our model has those $\Pi$-sorts whose codomains are pointed.  

\begin{theorem}
For all contexts $\Omega$, $X \in \mathit{St}(\Omega)$, $Y \in \mathit{PSt}(\Omega . X)$, our model supports the $\Pi$-sort $\Pi(X,Y)$.
\end{theorem}

\begin{proof}

UNFINISHED. TODO.
Given $X \in \mathit{St}(\Omega)$ and $Y \in \mathit{St}(\Omega . X)$ we define the semantic sort $\Pi(X,Y) \in \mathit{St}(\Omega)$ as 
$$\omega \in \Omega \mapsto \fm{Y_{(\omega,x)}}{x \in X_\omega}$$
where above, the right-hand-side is a poset-indexed family of posets considered as a poset. Indeed, given $x \leq x' \in X_\omega$ we have $(\omega, i(x)) = (\omega,x) \leq (\omega,x')$ and hence a monotone injection $i : Y_{(\omega,x)} \to Y_{(\omega,x')}$. 

\end{proof}


\end{document}
